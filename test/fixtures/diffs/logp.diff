6f41b9b0a8150e165cd297ae3e00129766cf8a9b Splits Results into separate file
diff --git a/README.md b/README.md
index fc64cd8..2a21457 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,8 @@
 # diffence
 
-Checks a git diff for offensive content.
-Golang 1.7+
+- Checks a git diff for offensive content.
+- Golang 1.7+
+- [Documentation on GoDoc](https://godoc.org/github.com/techjacker/diffence).
 
 -----------------------------------------------------------
 ## Install
diff --git a/TODO.md b/TODO.md
index dfdc4da..9c7dcbb 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,3 +1,5 @@
+add results tests
+
 add logger
 	- Logger interface fn arg - diff backends possible
 		- see in docs - default logger to be used
diff --git a/check.go b/check.go
index 448acc0..c2b81cc 100644
--- a/check.go
+++ b/check.go
@@ -2,20 +2,6 @@ package diffence
 
 import "io"
 
-// MatchedRules is slice of matched rules for each file in diff
-// [filepath] => Rule{rule1, rule2}
-type MatchedRules map[string][]Rule
-
-// Results is a slice of Result structs
-type Results []Result
-
-// Result compiles the results of matched rules for a diff
-type Result struct {
-	// Have any of the files matches against the rules?
-	Matched      bool
-	MatchedRules MatchedRules
-}
-
 // Checker checks diffs for rule violations
 type Checker interface {
 	Check(io.Reader) (Result, error)
diff --git a/results.go b/results.go
new file mode 100644
index 0000000..ac6ca0f
--- /dev/null
+++ b/results.go
@@ -0,0 +1,31 @@
+package diffence
+
+// Results is a slice of Result structs
+type Results []Result
+
+// Matches returns the number of diffs which had at least one file match against any rules
+func (r Results) Matches() int {
+	x := 0
+	for _, v := range r {
+		if v.Matches() > 0 {
+			x++
+		}
+	}
+	return x
+}
+
+// Result compiles the results of matched rules for a diff
+type Result struct {
+	// Have any of the files matches against the rules?
+	Matched      bool
+	MatchedRules MatchedRules
+}
+
+// Matches returns the number of files in the diff that matched against any of the rules
+func (r Result) Matches() int {
+	return len(r.MatchedRules)
+}
+
+// MatchedRules is slice of matched rules for each file in diff
+// [filepath] => Rule{rule1, rule2}
+type MatchedRules map[string][]Rule
diff --git a/rule.go b/rule.go
index 2d78e45..93e8e22 100644
--- a/rule.go
+++ b/rule.go
@@ -1,6 +1,5 @@
 package diffence
 
-// Rule is the format for supplying rules to Diffence to check diffs against
 type Rule struct {
 	Caption     string      `'Rule':"caption"`
 	Description interface{} `'Rule':"description"`
7794f2a7e0c35774f531a74280534374075a9c9e Adds Checker and Results
diff --git a/check.go b/check.go
index 15f0259..448acc0 100644
--- a/check.go
+++ b/check.go
@@ -2,14 +2,38 @@ package diffence
 
 import "io"
 
-// Results is hash of results matched for each filepath in a git diff
+// MatchedRules is slice of matched rules for each file in diff
 // [filepath] => Rule{rule1, rule2}
-type Results map[string][]Rule
+type MatchedRules map[string][]Rule
 
-// CheckDiffs is a clean syntax, inefficient way of
-// finding diffs that match the supplied rules
-func CheckDiffs(r io.Reader, rules *[]Rule) (Results, error) {
-	res := Results{}
+// Results is a slice of Result structs
+type Results []Result
+
+// Result compiles the results of matched rules for a diff
+type Result struct {
+	// Have any of the files matches against the rules?
+	Matched      bool
+	MatchedRules MatchedRules
+}
+
+// Checker checks diffs for rule violations
+type Checker interface {
+	Check(io.Reader) (Result, error)
+}
+
+// DiffChecker checks an io.Reader for matches against the supplied ruleset
+type DiffChecker struct {
+	Rules *[]Rule
+}
+
+// Check is a clean syntax but memory inefficient
+// method for finding diffs that match the supplied rules
+// (use an array instead of a map for better performance)
+func (dc DiffChecker) Check(r io.Reader) (Result, error) {
+	res := Result{
+		Matched:      false,
+		MatchedRules: make(map[string][]Rule),
+	}
 
 	diffs, err := SplitDiffs(r)
 	if err != nil || len(diffs) < 1 {
@@ -17,10 +41,13 @@ func CheckDiffs(r io.Reader, rules *[]Rule) (Results, error) {
 	}
 
 	for _, d := range diffs {
-		res[d.filePath] = []Rule{}
-		for _, r := range *rules {
+		for _, r := range *dc.Rules {
 			if r.Match(d.filePath) {
-				res[d.filePath] = append(res[d.filePath], r)
+				res.Matched = true
+				if _, ok := res.MatchedRules[d.filePath]; !ok {
+					res.MatchedRules[d.filePath] = []Rule{}
+				}
+				res.MatchedRules[d.filePath] = append(res.MatchedRules[d.filePath], r)
 			}
 		}
 	}
diff --git a/check_test.go b/check_test.go
index 0b611c3..2519018 100644
--- a/check_test.go
+++ b/check_test.go
@@ -19,7 +19,7 @@ func TestCheckDiffs(t *testing.T) {
 	tests := []struct {
 		name    string
 		args    args
-		want    Results
+		want    Result
 		wantErr bool
 	}{
 		{
@@ -28,8 +28,11 @@ func TestCheckDiffs(t *testing.T) {
 				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
 				rules: ruleSingle,
 			},
-			want: Results{
-				"path/to/password.txt": *ruleSingle,
+			want: Result{
+				Matched: true,
+				MatchedRules: MatchedRules{
+					"path/to/password.txt": *ruleSingle,
+				},
 			},
 			wantErr: false,
 		},
@@ -39,8 +42,11 @@ func TestCheckDiffs(t *testing.T) {
 				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
 				rules: ruleMulti,
 			},
-			want: Results{
-				"path/to/password.txt": *ruleSingle,
+			want: Result{
+				Matched: true,
+				MatchedRules: MatchedRules{
+					"path/to/password.txt": *ruleSingle,
+				},
 			},
 			wantErr: false,
 		},
@@ -50,9 +56,12 @@ func TestCheckDiffs(t *testing.T) {
 				r:     getFixtureFile("test/fixtures/diffs/multi_fail.diff"),
 				rules: ruleMulti,
 			},
-			want: Results{
-				"path/to/password.txt": []Rule{(*ruleMulti)[0]},
-				"another/file/aws.pem": []Rule{(*ruleMulti)[1]},
+			want: Result{
+				Matched: true,
+				MatchedRules: MatchedRules{
+					"path/to/password.txt": []Rule{(*ruleMulti)[0]},
+					"another/file/aws.pem": []Rule{(*ruleMulti)[1]},
+				},
 			},
 			wantErr: false,
 		},
@@ -62,13 +71,17 @@ func TestCheckDiffs(t *testing.T) {
 				r:     bytes.NewReader([]byte("not a diff")),
 				rules: ruleMulti,
 			},
-			want:    Results{},
+			want: Result{
+				Matched:      false,
+				MatchedRules: MatchedRules{},
+			},
 			wantErr: true,
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			got, err := CheckDiffs(tt.args.r, tt.args.rules)
+			dc := DiffChecker{tt.args.rules}
+			got, err := dc.Check(tt.args.r)
 			if (err != nil) != tt.wantErr {
 				t.Errorf("CheckDiffs() error = %v, wantErr %v", err, tt.wantErr)
 				return
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index 08044af..098342c 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -5,48 +5,30 @@ import (
 	"fmt"
 	"log"
 	"os"
-	"path"
-	"runtime"
 
-	df "github.com/techjacker/diffence"
+	"github.com/techjacker/diffence"
 )
 
-const rulesPath = "../../test/fixtures/rules/gitrob.json"
+const rulesPath = "test/fixtures/rules/gitrob.json"
 
 func main() {
-	_, cmd, _, _ := runtime.Caller(0)
-	rules, err := df.ReadRulesFromFile(path.Join(path.Dir(cmd), rulesPath))
-	if err != nil {
-		log.Fatalf("Cannot read rule file: %s\n", err)
-		return
-	}
 
 	info, _ := os.Stdin.Stat()
 	if (info.Mode() & os.ModeCharDevice) == os.ModeCharDevice {
 		log.Fatalln("The command is intended to work with pipes.")
 	}
 
-	res, err := df.CheckDiffs(bufio.NewReader(os.Stdin), rules)
+	diff := diffence.DiffChecker{diffence.LoadRulesJSONFromPwd(rulesPath)}
+	res, err := diff.Check(bufio.NewReader(os.Stdin))
 	if err != nil {
 		log.Fatalf("Error reading diff\n%s\n", err)
 		return
 	}
 
-	dirty := false
-	for k, v := range res {
-		if len(v) > 0 {
-			dirty = true
-			fmt.Printf("File %s violates %d rules:\n", k, len(v))
-			for _, r := range v {
-				fmt.Printf("\n%s\n", r.String())
-			}
-		}
-	}
-
-	if dirty == false {
-		fmt.Printf("Diff contains no offenses\n\n")
-		os.Exit(0)
+	if res.Matched == true {
+		fmt.Printf("Diff contains offenses\n\n")
+		os.Exit(1)
 	}
-	// dirty == true
-	os.Exit(1)
+	fmt.Printf("Diff contains NO offenses\n\n")
+	os.Exit(0)
 }
diff --git a/rule.go b/rule.go
index 93e8e22..2d78e45 100644
--- a/rule.go
+++ b/rule.go
@@ -1,5 +1,6 @@
 package diffence
 
+// Rule is the format for supplying rules to Diffence to check diffs against
 type Rule struct {
 	Caption     string      `'Rule':"caption"`
 	Description interface{} `'Rule':"description"`
diff --git a/rules.go b/rules.go
index 61b5dc9..7cea1a7 100644
--- a/rules.go
+++ b/rules.go
@@ -2,11 +2,24 @@ package diffence
 
 import (
 	"encoding/json"
+	"fmt"
 	"os"
+	"path"
+	"runtime"
 )
 
-// ReadRulesFromFile reads rules from the local filesystem
-func ReadRulesFromFile(filePath string) (*[]Rule, error) {
+// LoadRulesJSONFromPwd reads a rules JSON from a path relative to the process's pwd
+func LoadRulesJSONFromPwd(rulesPath string) *[]Rule {
+	_, cmd, _, _ := runtime.Caller(0)
+	rules, err := LoadRulesJSON(path.Join(path.Dir(cmd), rulesPath))
+	if err != nil {
+		panic(fmt.Sprintf("Cannot read rule file: %s\n", err))
+	}
+	return rules
+}
+
+// LoadRulesJSON reads a file of JSON rules from the local filesystem
+func LoadRulesJSON(filePath string) (*[]Rule, error) {
 	rules := &[]Rule{}
 
 	f, err := os.Open(filePath)
diff --git a/rules_test.go b/rules_test.go
index 78adb0a..5f5a6d0 100644
--- a/rules_test.go
+++ b/rules_test.go
@@ -38,13 +38,13 @@ func Test_readRules(t *testing.T) {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			got, err := ReadRulesFromFile(tt.args.filePath)
+			got, err := LoadRulesJSON(tt.args.filePath)
 			if (err != nil) != tt.wantErr {
-				t.Errorf("ReadRulesFromFile() error = %v, wantErr %v", err, tt.wantErr)
+				t.Errorf("LoadRulesJSON() error = %v, wantErr %v", err, tt.wantErr)
 				return
 			}
 			if !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("ReadRulesFromFile() = %v, want %v", got, tt.want)
+				t.Errorf("LoadRulesJSON() = %v, want %v", got, tt.want)
 			}
 		})
 	}
diff --git a/testhelpers_test.go b/testhelpers_test.go
index 644900d..0a60435 100644
--- a/testhelpers_test.go
+++ b/testhelpers_test.go
@@ -19,7 +19,7 @@ func getFixtureFile(filename string) io.Reader {
 }
 
 func getRuleFile(filename string) *[]Rule {
-	rules, err := ReadRulesFromFile(filename)
+	rules, err := LoadRulesJSON(filename)
 	if err != nil {
 		panic(err)
 	}
50bf1cdde42823e11e78a1026e3a7cfc7bc78e2f Adds MIT License
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..1605940
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2017   
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
bf0a0c7499036872255fb6591ad57557d7ec375a Exports Rule struct
diff --git a/.realize/realize.yaml b/.realize/realize.yaml
index e53e7df..8ae2b05 100644
--- a/.realize/realize.yaml
+++ b/.realize/realize.yaml
@@ -25,7 +25,7 @@ projects:
     after: []
     paths:
     - /
-    - /cmd/diffence
+    # - /cmd/diffence
     ignore_paths:
     - bin
     - cmd
diff --git a/TODO.md b/TODO.md
index 1be69ee..dfdc4da 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,7 +1,3 @@
-** make rule public > Rule
-	- disable linter for just this file
-	- pull request to interfacer
-
 add logger
 	- Logger interface fn arg - diff backends possible
 		- see in docs - default logger to be used
@@ -25,6 +21,9 @@ write git hook integrations:
 	- yelp's pre-commit
 	- overcommit
 
+-----------------------------------------------------------
+pull request gojson lib - add description flag
+	- re-enable lint githook (disable for that file)
 
 -----------------------------------------------------------
 github integration - HTTP server
@@ -32,6 +31,14 @@ github integration - HTTP server
 
 -----------------------------------------------------------
 -----------------------------------------------------------
+config
+	- rule file locations
+		- fs
+		- http
+	- rule file for:
+		1. filepaths
+		2. added lines
+
 -----------------------------------------------------------
 -----------------------------------------------------------
 -----------------------------------------------------------
@@ -61,16 +68,6 @@ add option to add multiple rules files
 	- bufio.MultiReader
 
 -----------------------------------------------------------
-
-export rule
-	-> rename to Rule
-	- re-enable lint githook (disable for that file)
-	- pull request gojson lib - add description flag
-
------------------------------------------------------------
-
-
------------------------------------------------------------
 -----------------------------------------------------------
 Add benchmarking
 
diff --git a/check.go b/check.go
index 9c61d3e..15f0259 100644
--- a/check.go
+++ b/check.go
@@ -3,12 +3,12 @@ package diffence
 import "io"
 
 // Results is hash of results matched for each filepath in a git diff
-// [filepath] => rule{rule1, rule2}
-type Results map[string][]rule
+// [filepath] => Rule{rule1, rule2}
+type Results map[string][]Rule
 
 // CheckDiffs is a clean syntax, inefficient way of
 // finding diffs that match the supplied rules
-func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
+func CheckDiffs(r io.Reader, rules *[]Rule) (Results, error) {
 	res := Results{}
 
 	diffs, err := SplitDiffs(r)
@@ -17,7 +17,7 @@ func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
 	}
 
 	for _, d := range diffs {
-		res[d.filePath] = []rule{}
+		res[d.filePath] = []Rule{}
 		for _, r := range *rules {
 			if r.Match(d.filePath) {
 				res[d.filePath] = append(res[d.filePath], r)
diff --git a/check_test.go b/check_test.go
index b647ed8..0b611c3 100644
--- a/check_test.go
+++ b/check_test.go
@@ -10,7 +10,7 @@ import (
 func TestCheckDiffs(t *testing.T) {
 	type args struct {
 		r     io.Reader
-		rules *[]rule
+		rules *[]Rule
 	}
 
 	ruleSingle := getRuleFile("test/fixtures/rules/rules.json")
@@ -51,8 +51,8 @@ func TestCheckDiffs(t *testing.T) {
 				rules: ruleMulti,
 			},
 			want: Results{
-				"path/to/password.txt": []rule{(*ruleMulti)[0]},
-				"another/file/aws.pem": []rule{(*ruleMulti)[1]},
+				"path/to/password.txt": []Rule{(*ruleMulti)[0]},
+				"another/file/aws.pem": []Rule{(*ruleMulti)[1]},
 			},
 			wantErr: false,
 		},
diff --git a/rule.go b/rule.go
index ee60223..93e8e22 100644
--- a/rule.go
+++ b/rule.go
@@ -1,9 +1,9 @@
 package diffence
 
-type rule struct {
-	Caption     string      `'rule':"caption"`
-	Description interface{} `'rule':"description"`
-	Part        string      `'rule':"part"`
-	Pattern     string      `'rule':"pattern"`
-	Type        string      `'rule':"type"`
+type Rule struct {
+	Caption     string      `'Rule':"caption"`
+	Description interface{} `'Rule':"description"`
+	Part        string      `'Rule':"part"`
+	Pattern     string      `'Rule':"pattern"`
+	Type        string      `'Rule':"type"`
 }
diff --git a/rule_tmpl.go b/rule_tmpl.go
index bcebc88..fd4d28c 100644
--- a/rule_tmpl.go
+++ b/rule_tmpl.go
@@ -7,7 +7,7 @@ import (
 	"strings"
 )
 
-//go:generate gojson -name rule -input test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
+//go:generate gojson -name Rule -input test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'Rule'
 
 // https://github.com/michenriksen/gitrob#signature-keys
 const (
@@ -30,7 +30,7 @@ const (
 )
 
 // Match runs rules against input strings
-func (r *rule) Match(in string) bool {
+func (r *Rule) Match(in string) bool {
 	in = r.extractPart(in)
 	switch r.Type {
 	case RuleTypeRegex:
@@ -42,7 +42,7 @@ func (r *rule) Match(in string) bool {
 	return false
 }
 
-func (r *rule) extractPart(in string) string {
+func (r *Rule) extractPart(in string) string {
 	switch r.Part {
 	case RulePartFilename:
 		return path.Base(in)
@@ -53,7 +53,7 @@ func (r *rule) extractPart(in string) string {
 }
 
 // String returns a string representation of the rule
-func (r *rule) String() string {
+func (r *Rule) String() string {
 	return fmt.Sprintf("Caption: %s\n", r.Caption) +
 		fmt.Sprintf("Description: %#v\n", r.Description) +
 		fmt.Sprintf("Part: %s\n", r.Part) +
diff --git a/rule_tmpl_test.go b/rule_tmpl_test.go
index 23028ed..e7b4ccd 100644
--- a/rule_tmpl_test.go
+++ b/rule_tmpl_test.go
@@ -94,7 +94,7 @@ func Test_rule_Match(t *testing.T) {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			r := &rule{
+			r := &Rule{
 				Caption:     tt.fields.Caption,
 				Description: tt.fields.Description,
 				Part:        tt.fields.Part,
diff --git a/rules.go b/rules.go
index b460c2f..61b5dc9 100644
--- a/rules.go
+++ b/rules.go
@@ -6,8 +6,8 @@ import (
 )
 
 // ReadRulesFromFile reads rules from the local filesystem
-func ReadRulesFromFile(filePath string) (*[]rule, error) {
-	rules := &[]rule{}
+func ReadRulesFromFile(filePath string) (*[]Rule, error) {
+	rules := &[]Rule{}
 
 	f, err := os.Open(filePath)
 	if err != nil {
diff --git a/rules_test.go b/rules_test.go
index 7cc4fe9..78adb0a 100644
--- a/rules_test.go
+++ b/rules_test.go
@@ -12,13 +12,13 @@ func Test_readRules(t *testing.T) {
 	tests := []struct {
 		name    string
 		args    args
-		want    *[]rule
+		want    *[]Rule
 		wantErr bool
 	}{
 		{
 			name: "Read rules from file",
 			args: args{filePath: "test/fixtures/rules/rules.json"},
-			want: &[]rule{
+			want: &[]Rule{
 				{
 					Caption:     "Contains word: password",
 					Description: nil,
@@ -32,7 +32,7 @@ func Test_readRules(t *testing.T) {
 		{
 			name:    "Read rules from file",
 			args:    args{filePath: "test/fixtures/does_not_exist.json"},
-			want:    &[]rule{},
+			want:    &[]Rule{},
 			wantErr: true,
 		},
 	}
diff --git a/testhelpers_test.go b/testhelpers_test.go
index c0f1848..644900d 100644
--- a/testhelpers_test.go
+++ b/testhelpers_test.go
@@ -18,7 +18,7 @@ func getFixtureFile(filename string) io.Reader {
 	return file
 }
 
-func getRuleFile(filename string) *[]rule {
+func getRuleFile(filename string) *[]Rule {
 	rules, err := ReadRulesFromFile(filename)
 	if err != nil {
 		panic(err)
e8b187575869fb81dbba5e0d1bdbbf4deec11484 Adds realize
diff --git a/.realize/realize.yaml b/.realize/realize.yaml
new file mode 100644
index 0000000..e53e7df
--- /dev/null
+++ b/.realize/realize.yaml
@@ -0,0 +1,42 @@
+settings:
+  resources:
+    streams: streams.log
+    logs: logs.log
+    errors: errors.log
+  server:
+    enable: true
+    open: false
+    host: localhost
+    port: 5001
+  config:
+    flimit: 0
+projects:
+- name: diffence
+  path: /
+  fmt: true
+  test: true
+  generate: false
+  bin: true
+  build: false
+  run: false
+  params: []
+  watcher:
+    before: []
+    after: []
+    paths:
+    - /
+    - /cmd/diffence
+    ignore_paths:
+    - bin
+    - cmd
+    - test
+    - vendor
+    exts:
+    - .go
+    preview: false
+  cli:
+    streams: true
+  file:
+    streams: false
+    logs: false
+    errors: false
diff --git a/diff_test.go b/diff_test.go
index ac360d9..13f8a04 100644
--- a/diff_test.go
+++ b/diff_test.go
@@ -75,7 +75,7 @@ func TestSplitDiffs(t *testing.T) {
 				r: getFixtureFile("test/fixtures/diffs/single.diff"),
 			},
 			want: []wantDiff{
-				wantDiff{
+				{
 					header:   "diff --git a/README.md b/README.md",
 					filepath: "README.md",
 				},
@@ -87,31 +87,31 @@ func TestSplitDiffs(t *testing.T) {
 				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
 			},
 			want: []wantDiff{
-				wantDiff{
+				{
 					header:   "diff --git a/TODO.md b/TODO.md",
 					filepath: "TODO.md",
 				},
-				wantDiff{
+				{
 					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
 					filepath: "systemdlogger/aws.py",
 				},
-				wantDiff{
+				{
 					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
 					filepath: "systemdlogger/cloudwatch.py",
 				},
-				wantDiff{
+				{
 					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
 					filepath: "tests/fixtures/config.json",
 				},
-				wantDiff{
+				{
 					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
 					filepath: "tests/test_aws.py",
 				},
-				wantDiff{
+				{
 					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
 					filepath: "tests/test_cloudwatch.py",
 				},
-				wantDiff{
+				{
 					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
 					filepath: "tests/test_runner_integration.py",
 				},
7334a6dc89430f3a062b4cb21277decdd836ceb7 Converts rules section of readme to checklist
diff --git a/README.md b/README.md
index 47c59c0..fc64cd8 100644
--- a/README.md
+++ b/README.md
@@ -47,9 +47,11 @@ Type: match
 
 -----------------------------------------------------------
 ## Rules
-- currently uses [gitrob rules](https://github.com/michenriksen/gitrob#signature-keys)
-- file body rules coming soon (gitrob rules only check the filename for violations)
-- option to input your own rules coming soon
+- [x] Analyse filepaths with [gitrob rules](https://github.com/michenriksen/gitrob#signature-keys)
+- [ ] Analyse added lines - need to find/create ruleset that can analyse file contents
+- [ ] Add option to use your own rules again file path/contents
+
+
 
 -----------------------------------------------------------
 ## Tests
diff --git a/TODO.md b/TODO.md
index 2db904d..1be69ee 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,12 +1,29 @@
+** make rule public > Rule
+	- disable linter for just this file
+	- pull request to interfacer
+
+add logger
+	- Logger interface fn arg - diff backends possible
+		- see in docs - default logger to be used
+		- alternative = return string (for email/alt export)
+		- cloudwatch/loggly alts  etc
+	- CLI logger
+		- add color ([OK] [ERR])
+		- fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
+
 Speed up - pauses on stin pipe
 	// r := bytes.NewReader([]byte("hello world"))
  	writer := bufio.NewWriter(outfile)
     defer writer.Flush()
 
-add logger
-	- put in own struct - see in docs
-	- add color ([OK] [ERR])
-	- fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
+Add context.cancel
+	- sigterm/cancel -> stop CLI
+
+
+-----------------------------------------------------------
+write git hook integrations:
+	- yelp's pre-commit
+	- overcommit
 
 
 -----------------------------------------------------------
1349b9c318dae5926a1c3357018f69f30f6c3505 Updates rule generation command to use correct source path
diff --git a/rule_tmpl.go b/rule_tmpl.go
index ae81a56..bcebc88 100644
--- a/rule_tmpl.go
+++ b/rule_tmpl.go
@@ -7,11 +7,9 @@ import (
 	"strings"
 )
 
-//go:generate gojson -name rule -input ./../test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
+//go:generate gojson -name rule -input test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
 
-////////////////////////////////////////////////////////
 // https://github.com/michenriksen/gitrob#signature-keys
-////////////////////////////////////////////////////////
 const (
 	// RuleTypeRegex is the regex type for pattern matching
 	RuleTypeRegex = "regex"
@@ -56,9 +54,9 @@ func (r *rule) extractPart(in string) string {
 
 // String returns a string representation of the rule
 func (r *rule) String() string {
-	return fmt.Sprintf("Caption: %#s\n", r.Caption) +
+	return fmt.Sprintf("Caption: %s\n", r.Caption) +
 		fmt.Sprintf("Description: %#v\n", r.Description) +
-		fmt.Sprintf("Part: %#s\n", r.Part) +
-		fmt.Sprintf("Pattern: %#s\n", r.Pattern) +
-		fmt.Sprintf("Type: %#s\n\n", r.Type)
+		fmt.Sprintf("Part: %s\n", r.Part) +
+		fmt.Sprintf("Pattern: %s\n", r.Pattern) +
+		fmt.Sprintf("Type: %s\n\n", r.Type)
 }
15dacb5e4049ed8382a50cc3275d02451fb3550f Makes path to rules file a constant in CLI
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index 6fd1960..08044af 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -11,10 +11,11 @@ import (
 	df "github.com/techjacker/diffence"
 )
 
+const rulesPath = "../../test/fixtures/rules/gitrob.json"
+
 func main() {
-	gitrobRuleFile := "../../test/fixtures/rules/gitrob.json"
 	_, cmd, _, _ := runtime.Caller(0)
-	rules, err := df.ReadRulesFromFile(path.Join(path.Dir(cmd), gitrobRuleFile))
+	rules, err := df.ReadRulesFromFile(path.Join(path.Dir(cmd), rulesPath))
 	if err != nil {
 		log.Fatalf("Cannot read rule file: %s\n", err)
 		return
1262fb5bb7128e04eb8dbdc727f4870e4e543fc3 Validates that CLI receives piped input from STDIN
diff --git a/.gitignore b/.gitignore
index fb88369..20710b7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,4 @@
-./diffence
+/diffence
 releases
 
 # Compiled Object files, Static and Dynamic libs (Shared Objects)
diff --git a/TODO.md b/TODO.md
index d323d59..2db904d 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,4 +1,13 @@
-stop CLI hanging on empty input from stdin
+Speed up - pauses on stin pipe
+	// r := bytes.NewReader([]byte("hello world"))
+ 	writer := bufio.NewWriter(outfile)
+    defer writer.Flush()
+
+add logger
+	- put in own struct - see in docs
+	- add color ([OK] [ERR])
+	- fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
+
 
 -----------------------------------------------------------
 github integration - HTTP server
@@ -63,7 +72,7 @@ Perf
 
 
 -----------------------------------------------------------
-add logger
+
 
 -----------------------------------------------------------
 add build task -> convert JSON rules into golang struct
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index e0203b1..6fd1960 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -1,6 +1,7 @@
 package main
 
 import (
+	"bufio"
 	"fmt"
 	"log"
 	"os"
@@ -11,18 +12,22 @@ import (
 )
 
 func main() {
-	// r := bytes.NewReader([]byte("hello world"))
 	gitrobRuleFile := "../../test/fixtures/rules/gitrob.json"
 	_, cmd, _, _ := runtime.Caller(0)
 	rules, err := df.ReadRulesFromFile(path.Join(path.Dir(cmd), gitrobRuleFile))
 	if err != nil {
-		log.Fatalf("\nCannot read rule file: %s\n", err)
+		log.Fatalf("Cannot read rule file: %s\n", err)
 		return
 	}
 
-	res, err := df.CheckDiffs(os.Stdin, rules)
+	info, _ := os.Stdin.Stat()
+	if (info.Mode() & os.ModeCharDevice) == os.ModeCharDevice {
+		log.Fatalln("The command is intended to work with pipes.")
+	}
+
+	res, err := df.CheckDiffs(bufio.NewReader(os.Stdin), rules)
 	if err != nil {
-		log.Fatalf("\nError reading diff\n%s\n", err)
+		log.Fatalf("Error reading diff\n%s\n", err)
 		return
 	}
 
@@ -38,7 +43,7 @@ func main() {
 	}
 
 	if dirty == false {
-		fmt.Printf("\nDiff contains no offenses\n\n")
+		fmt.Printf("Diff contains no offenses\n\n")
 		os.Exit(0)
 	}
 	// dirty == true
diff --git a/diffence b/diffence
deleted file mode 100755
index 11d6ebf..0000000
Binary files a/diffence and /dev/null differ
a05091cbd495d45a60728bfdf510592980ebd965 Updates example usage in README
diff --git a/README.md b/README.md
index 5925e3c..47c59c0 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Golang 1.7+
 
 ### CLI
 ```
-go get -u github.com/techjacker/diffence/cmd/diffence
+$ go get -u github.com/techjacker/diffence/cmd/diffence
 ```
 
 ### Library
 ```
-go get -u github.com/techjacker/diffence
+$ go get -u github.com/techjacker/diffence
 ```
 
 -----------------------------------------------------------
@@ -24,9 +24,25 @@ go get -u github.com/techjacker/diffence
 
 ### Example Usage
 ```
-touch key.pem
-git add -N key.pem
-git diff HEAD |diffence
+$ touch key.pem
+
+$ git add -N key.pem
+
+$ git diff --stat HEAD
+gds HEAD
+ key.pem | 0
+ 1 file changed, 0 insertions(+), 0 deletions(-)
+
+$ git diff HEAD |diffence
+File key.pem violates 1 rules:
+
+Caption: Potential cryptographic private key
+Description: <nil>
+Part: extension
+Pattern: pem
+Type: match
+
+
 ```
 
 -----------------------------------------------------------
@@ -38,7 +54,7 @@ git diff HEAD |diffence
 -----------------------------------------------------------
 ## Tests
 ```
-go test ./...
+$ go test ./...
 ```
 
 -----------------------------------------------------------
@@ -54,15 +70,15 @@ $ release
 
 #### Build & Run Locally
 ```shell
-go install -race ./cmd/diffence
+$ go install -race ./cmd/diffence
 ```
 OR
 ```shell
-go build -race ./cmd/diffence
+$ go build -race ./cmd/diffence
 ```
 
 #### Check for race conditions
 ```shell
-go run -race ./cmd/diffence/main.go
+$ go run -race ./cmd/diffence/main.go
 ```
 
diff --git a/TODO.md b/TODO.md
index b4b285c..d323d59 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,6 +1,14 @@
 stop CLI hanging on empty input from stdin
 
 -----------------------------------------------------------
+github integration - HTTP server
+- set up fission on kubernetes
+
+-----------------------------------------------------------
+-----------------------------------------------------------
+-----------------------------------------------------------
+-----------------------------------------------------------
+-----------------------------------------------------------
 
 Add -config flag to CLI
 	- override default = gitrob rules
@@ -23,7 +31,8 @@ Add -config flag to CLI
 		}
 	}
 	```
-
+add option to add multiple rules files
+	- bufio.MultiReader
 
 -----------------------------------------------------------
 
@@ -54,17 +63,6 @@ Perf
 
 
 -----------------------------------------------------------
------------------------------------------------------------
-github integration - HTTP server
-- set up fission on kubernetes
-
------------------------------------------------------------
------------------------------------------------------------
-
-return just error from main function (vs bool, error)
-
------------------------------------------------------------
-
 add logger
 
 -----------------------------------------------------------
@@ -72,8 +70,7 @@ add build task -> convert JSON rules into golang struct
 	- make part of dockerfile?
 
 -----------------------------------------------------------
-add multiple rules files to be inputed
-	bufio.MultiReader
+
 
 -----------------------------------------------------------
 set up realize - live reload run tests etc
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index dad5152..e0203b1 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -30,7 +30,7 @@ func main() {
 	for k, v := range res {
 		if len(v) > 0 {
 			dirty = true
-			fmt.Printf("\nFile %s violates %d rules:\n", k, len(v))
+			fmt.Printf("File %s violates %d rules:\n", k, len(v))
 			for _, r := range v {
 				fmt.Printf("\n%s\n", r.String())
 			}
0bbb43b798029ae99a46bf493f4d0f34c632be76 CLI reads from stdin
diff --git a/Makefile b/Makefile
index bb4c3c8..f00d40b 100644
--- a/Makefile
+++ b/Makefile
@@ -5,6 +5,8 @@ COMMIT_ID = 94c52865e3b449ca594d09995b99efc28a24c53d
 RULES_DIR = test/fixtures/rules
 RULES_URL = https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json
 
+install:
+	@go install -race ./cmd/diffence
 
 lint:
 	@golint  -set_exit_status ./...
diff --git a/README.md b/README.md
index cf6d198..5925e3c 100644
--- a/README.md
+++ b/README.md
@@ -1,72 +1,48 @@
 # diffence
 
 Checks a git diff for offensive content.
-
 Golang 1.7+
 
 -----------------------------------------------------------
-
-## Install CLI tool
+## Install
 
 ### Binary
 [Download](../../releases) the latest stable release.
 
-### Source
-
-##### CLI tool
+### CLI
 ```
 go get -u github.com/techjacker/diffence/cmd/diffence
 ```
 
-##### Library
+### Library
 ```
 go get -u github.com/techjacker/diffence
 ```
 
 -----------------------------------------------------------
+## CLI tool
 
-## Usage
+### Example Usage
 ```
+touch key.pem
+git add -N key.pem
+git diff HEAD |diffence
 ```
 
 -----------------------------------------------------------
-## [Gitrob Rules - Signature Keys](https://github.com/michenriksen/gitrob#signature-keys)
-
-
-
-
+## Rules
+- currently uses [gitrob rules](https://github.com/michenriksen/gitrob#signature-keys)
+- file body rules coming soon (gitrob rules only check the filename for violations)
+- option to input your own rules coming soon
 
 -----------------------------------------------------------
-## JSON Configuration
-
-By default the CLI tool looks for config.json in $PWD. You can specify a custom location with the `config` flag, eg:
-
-```Shell
-diffence -config ./test/fixtures/config.json
-```
-
-
-#### Example JSON Config
-```json
-{
-	"rules": {
-		"jsonPath": "./test/fixtures/rules.json"
-	}
-}
-```
-
------------------------------------------------------------
-
 ## Tests
-
 ```
 go test ./...
 ```
 
 -----------------------------------------------------------
-
 ## Release
-
 Update the vars in ```env.sh```.
 
 ```shell
@@ -74,25 +50,19 @@ $ release
 ```
 
 -----------------------------------------------------------
-
 ## Local Development
 
-
 #### Build & Run Locally
 ```shell
-go install ./cmd/diffence && diffence -config ./test/fixtures/config.json
+go install -race ./cmd/diffence
 ```
-
 OR
-
 ```shell
-go build -race ./cmd/diffence && ./diffence -config ./test/fixtures/config.json
+go build -race ./cmd/diffence
 ```
 
-
 #### Check for race conditions
-
 ```shell
-go run -race ./cmd/diffence/main.go -config ./test/fixtures/config.json
+go run -race ./cmd/diffence/main.go
 ```
 
diff --git a/TODO.md b/TODO.md
index 9d61ede..b4b285c 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,9 +1,40 @@
+stop CLI hanging on empty input from stdin
+
+-----------------------------------------------------------
+
+Add -config flag to CLI
+	- override default = gitrob rules
+
+	-----------------------------------------------------------
+	## JSON Configuration
+
+	By default the CLI tool looks for config.json in $PWD. You can specify a custom location with the `config` flag, eg:
+
+	```Shell
+	diffence -config ./test/fixtures/config.json
+	```
+
+
+	#### Example JSON Config
+	```json
+	{
+		"rules": {
+			"jsonPath": "./test/fixtures/rules.json"
+		}
+	}
+	```
+
+
+-----------------------------------------------------------
+
 export rule
 	-> rename to Rule
 	- re-enable lint githook (disable for that file)
 	- pull request gojson lib - add description flag
 
 -----------------------------------------------------------
+
+
 -----------------------------------------------------------
 -----------------------------------------------------------
 Add benchmarking
diff --git a/check.go b/check.go
index 8cca068..9c61d3e 100644
--- a/check.go
+++ b/check.go
@@ -1,10 +1,6 @@
 package diffence
 
-import (
-	"io"
-
-	"github.com/y0ssar1an/q"
-)
+import "io"
 
 // Results is hash of results matched for each filepath in a git diff
 // [filepath] => rule{rule1, rule2}
@@ -14,9 +10,8 @@ type Results map[string][]rule
 // finding diffs that match the supplied rules
 func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
 	res := Results{}
+
 	diffs, err := SplitDiffs(r)
-	q.Q(len(diffs))
-	q.Q(err)
 	if err != nil || len(diffs) < 1 {
 		return res, err
 	}
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index 8531b8a..dad5152 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -1,29 +1,46 @@
 package main
 
 import (
-	"bytes"
 	"fmt"
+	"log"
 	"os"
+	"path"
+	"runtime"
 
-	"github.com/kr/pretty"
 	df "github.com/techjacker/diffence"
 )
 
 func main() {
-	r := bytes.NewReader([]byte("hello world"))
-
-	rules, err := df.ReadRulesFromFile("test/fixtures/rules/gitrob.json")
+	// r := bytes.NewReader([]byte("hello world"))
+	gitrobRuleFile := "../../test/fixtures/rules/gitrob.json"
+	_, cmd, _, _ := runtime.Caller(0)
+	rules, err := df.ReadRulesFromFile(path.Join(path.Dir(cmd), gitrobRuleFile))
 	if err != nil {
-		fmt.Printf("\nCannot read rule file: %s\n", err)
-		os.Exit(1)
+		log.Fatalf("\nCannot read rule file: %s\n", err)
 		return
 	}
 
-	res, err := df.CheckDiffs(r, rules)
+	res, err := df.CheckDiffs(os.Stdin, rules)
 	if err != nil {
-		fmt.Printf("\nError reading diff\n%s\n", err)
-		os.Exit(1)
+		log.Fatalf("\nError reading diff\n%s\n", err)
 		return
 	}
-	fmt.Printf("%#v\n", pretty.Formatter(res))
+
+	dirty := false
+	for k, v := range res {
+		if len(v) > 0 {
+			dirty = true
+			fmt.Printf("\nFile %s violates %d rules:\n", k, len(v))
+			for _, r := range v {
+				fmt.Printf("\n%s\n", r.String())
+			}
+		}
+	}
+
+	if dirty == false {
+		fmt.Printf("\nDiff contains no offenses\n\n")
+		os.Exit(0)
+	}
+	// dirty == true
+	os.Exit(1)
 }
diff --git a/rule_tmpl.go b/rule_tmpl.go
index b36ad09..ae81a56 100644
--- a/rule_tmpl.go
+++ b/rule_tmpl.go
@@ -1,6 +1,7 @@
 package diffence
 
 import (
+	"fmt"
 	"path"
 	"regexp"
 	"strings"
@@ -52,3 +53,12 @@ func (r *rule) extractPart(in string) string {
 	}
 	return in
 }
+
+// String returns a string representation of the rule
+func (r *rule) String() string {
+	return fmt.Sprintf("Caption: %#s\n", r.Caption) +
+		fmt.Sprintf("Description: %#v\n", r.Description) +
+		fmt.Sprintf("Part: %#s\n", r.Part) +
+		fmt.Sprintf("Pattern: %#s\n", r.Pattern) +
+		fmt.Sprintf("Type: %#s\n\n", r.Type)
+}
b350cc32859486852942f315b027556a92bca4c9 Moves lib files to root dir
diff --git a/Makefile b/Makefile
index 4bb133e..bb4c3c8 100644
--- a/Makefile
+++ b/Makefile
@@ -23,13 +23,13 @@ run:
 	@go build -race ./cmd/diffence && ./diffence
 
 test:
-	@go test ./lib/...
+	@go test ./...
 
 test-cover:
-	@go test -cover ./lib/...
+	@go test -cover ./...
 
 test-race:
-	@go test -race ./lib/...
+	@go test -race ./...
 
 
 .PHONY: test run
diff --git a/README.md b/README.md
index 45f3e97..cf6d198 100644
--- a/README.md
+++ b/README.md
@@ -12,10 +12,16 @@ Golang 1.7+
 [Download](../../releases) the latest stable release.
 
 ### Source
+
+##### CLI tool
 ```
 go get -u github.com/techjacker/diffence/cmd/diffence
 ```
 
+##### Library
+```
+go get -u github.com/techjacker/diffence
+```
 
 -----------------------------------------------------------
 
@@ -80,7 +86,7 @@ go install ./cmd/diffence && diffence -config ./test/fixtures/config.json
 OR
 
 ```shell
-go build ./cmd/diffence && ./diffence -config ./test/fixtures/config.json
+go build -race ./cmd/diffence && ./diffence -config ./test/fixtures/config.json
 ```
 
 
diff --git a/TODO.md b/TODO.md
index c0f48dd..9d61ede 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,11 +1,8 @@
-
 export rule
 	-> rename to Rule
 	- re-enable lint githook (disable for that file)
 	- pull request gojson lib - add description flag
 
-move files to root dir
-
 -----------------------------------------------------------
 -----------------------------------------------------------
 -----------------------------------------------------------
diff --git a/check.go b/check.go
new file mode 100644
index 0000000..8cca068
--- /dev/null
+++ b/check.go
@@ -0,0 +1,34 @@
+package diffence
+
+import (
+	"io"
+
+	"github.com/y0ssar1an/q"
+)
+
+// Results is hash of results matched for each filepath in a git diff
+// [filepath] => rule{rule1, rule2}
+type Results map[string][]rule
+
+// CheckDiffs is a clean syntax, inefficient way of
+// finding diffs that match the supplied rules
+func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
+	res := Results{}
+	diffs, err := SplitDiffs(r)
+	q.Q(len(diffs))
+	q.Q(err)
+	if err != nil || len(diffs) < 1 {
+		return res, err
+	}
+
+	for _, d := range diffs {
+		res[d.filePath] = []rule{}
+		for _, r := range *rules {
+			if r.Match(d.filePath) {
+				res[d.filePath] = append(res[d.filePath], r)
+			}
+		}
+	}
+
+	return res, err
+}
diff --git a/check_test.go b/check_test.go
new file mode 100644
index 0000000..b647ed8
--- /dev/null
+++ b/check_test.go
@@ -0,0 +1,81 @@
+package diffence
+
+import (
+	"bytes"
+	"io"
+	"reflect"
+	"testing"
+)
+
+func TestCheckDiffs(t *testing.T) {
+	type args struct {
+		r     io.Reader
+		rules *[]rule
+	}
+
+	ruleSingle := getRuleFile("test/fixtures/rules/rules.json")
+	ruleMulti := getRuleFile("test/fixtures/rules/rules_multi.json")
+
+	tests := []struct {
+		name    string
+		args    args
+		want    Results
+		wantErr bool
+	}{
+		{
+			name: "Recognises an offensive diff",
+			args: args{
+				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
+				rules: ruleSingle,
+			},
+			want: Results{
+				"path/to/password.txt": *ruleSingle,
+			},
+			wantErr: false,
+		},
+		{
+			name: "Recognises an offensive diff",
+			args: args{
+				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
+				rules: ruleMulti,
+			},
+			want: Results{
+				"path/to/password.txt": *ruleSingle,
+			},
+			wantErr: false,
+		},
+		{
+			name: "Recognises an offensive diff",
+			args: args{
+				r:     getFixtureFile("test/fixtures/diffs/multi_fail.diff"),
+				rules: ruleMulti,
+			},
+			want: Results{
+				"path/to/password.txt": []rule{(*ruleMulti)[0]},
+				"another/file/aws.pem": []rule{(*ruleMulti)[1]},
+			},
+			wantErr: false,
+		},
+		{
+			name: "Recognises non diff text",
+			args: args{
+				r:     bytes.NewReader([]byte("not a diff")),
+				rules: ruleMulti,
+			},
+			want:    Results{},
+			wantErr: true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := CheckDiffs(tt.args.r, tt.args.rules)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("CheckDiffs() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("CheckDiffs() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index 9a8a934..8531b8a 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -6,7 +6,7 @@ import (
 	"os"
 
 	"github.com/kr/pretty"
-	df "github.com/techjacker/diffence/lib"
+	df "github.com/techjacker/diffence"
 )
 
 func main() {
diff --git a/diff.go b/diff.go
new file mode 100644
index 0000000..8421e14
--- /dev/null
+++ b/diff.go
@@ -0,0 +1,108 @@
+package diffence
+
+import (
+	"bufio"
+	"bytes"
+	"fmt"
+	"io"
+	"strings"
+)
+
+// DiffItem is a diff struct for an inidividual file
+type DiffItem struct {
+	raw      string
+	filePath string
+	// addedText string
+	// match        bool
+	// matchedRules []rule
+}
+
+// SplitDiffs splits a single diff txt into an individual DiffItem for each
+// file changed
+func SplitDiffs(r io.Reader) ([]DiffItem, error) {
+
+	var err error
+	scanner := bufio.NewScanner(r)
+	scanner.Split(ScanDiffs)
+
+	// copy to temporary buffer because gets overwritten otherwise
+	// https://golang.org/pkg/bufio/#Scanner.Bytes
+	// "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be OVERWRITTEN by a subsequent call to Scan. It does no allocation."
+	buffer := bytes.NewBuffer(make([]byte, 0))
+	items := []DiffItem{}
+
+	for scanner.Scan() {
+		buffer.Write(scanner.Bytes())
+		raw := buffer.String()
+		filePath, err := extractFilePath(raw)
+		if err != nil {
+			return items, err
+		}
+		items = append(items, DiffItem{
+			raw:      raw,
+			filePath: filePath,
+		})
+		buffer.Reset()
+	}
+
+	if err != nil {
+		return items, err
+	}
+
+	return items, scanner.Err()
+}
+
+// ScanDiffs splits on the diff of an inidividual file
+func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
+	if atEOF && len(data) == 0 {
+		return 0, nil, nil
+	}
+
+	k, nextFileDiffIndex, dataLen := 0, 0, len(data)-1
+	for k < dataLen {
+		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
+			// how far advanced already (k)
+			// index after last \n char (+ i)
+			// start at next byte (+ 1)
+			nextFileDiffIndex = k + i + 1
+			if nextFileDiffIndex < dataLen && string(data[nextFileDiffIndex]) == "d" {
+				return nextFileDiffIndex, dropCR(data[0 : k+i]), nil
+			}
+			k += i + 1
+		} else {
+			k = dataLen
+		}
+	}
+	// If we're at EOF, we have a final, non-terminated line. Return it.
+	if atEOF {
+		return len(data), dropCR(data), nil
+	}
+	// Request more data.
+	return 0, nil, nil
+}
+
+func extractHeader(in string) (string, error) {
+	newLineIndex := strings.Index(in, "\n")
+	if newLineIndex < 0 {
+		return "", fmt.Errorf("not valid diff content:\n\n%s", in)
+	}
+	return in[:newLineIndex], nil
+}
+
+func extractFilePath(in string) (string, error) {
+	prefix := "b/"
+	pathBIndex := strings.Index(in, prefix)
+	newLineIndex := strings.Index(in, "\n")
+	if pathBIndex >= 0 && newLineIndex > pathBIndex {
+		return in[pathBIndex+len(prefix) : newLineIndex], nil
+	}
+	return "", fmt.Errorf("Not valid diff content:\n%s", in)
+}
+
+// dropCR drops a terminal \r from the data.
+func dropCR(data []byte) []byte {
+	if len(data) > 0 && data[len(data)-1] == '\r' {
+		return data[0 : len(data)-1]
+	}
+	return data
+}
diff --git a/diff_test.go b/diff_test.go
new file mode 100644
index 0000000..ac360d9
--- /dev/null
+++ b/diff_test.go
@@ -0,0 +1,208 @@
+package diffence
+
+import (
+	"bufio"
+	"bytes"
+	"io"
+	"reflect"
+	"testing"
+)
+
+func TestScanDiffsWithBufioScanner(t *testing.T) {
+	type args struct {
+		r io.Reader
+	}
+	tests := []struct {
+		name string
+		args args
+		want [][]byte
+	}{
+		{
+			name: "ScanDiffs() split fn",
+			args: args{r: bytes.NewReader(
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644" +
+						"\n" +
+						"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			)},
+			want: [][]byte{
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+				[]byte(
+					"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := [][]byte{}
+			scanner := bufio.NewScanner(tt.args.r)
+			scanner.Split(ScanDiffs)
+			for scanner.Scan() {
+				got = append(got, scanner.Bytes())
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestSplitDiffs(t *testing.T) {
+	type args struct {
+		r io.Reader
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want []wantDiff
+	}{
+		{
+			name: "Differ.Parse()",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/single.diff"),
+			},
+			want: []wantDiff{
+				wantDiff{
+					header:   "diff --git a/README.md b/README.md",
+					filepath: "README.md",
+				},
+			},
+		},
+		{
+			name: "Differ.Parse()",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
+			},
+			want: []wantDiff{
+				wantDiff{
+					header:   "diff --git a/TODO.md b/TODO.md",
+					filepath: "TODO.md",
+				},
+				wantDiff{
+					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
+					filepath: "systemdlogger/aws.py",
+				},
+				wantDiff{
+					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
+					filepath: "systemdlogger/cloudwatch.py",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
+					filepath: "tests/fixtures/config.json",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
+					filepath: "tests/test_aws.py",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
+					filepath: "tests/test_cloudwatch.py",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
+					filepath: "tests/test_runner_integration.py",
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+
+			// check for error scanning
+			items, err := SplitDiffs(tt.args.r)
+			if err != nil {
+				t.Fatalf("SplitDiffs threw error %#v", err)
+			}
+
+			// check extracting metadata
+			for i, di := range items {
+				header, _ := extractHeader(di.raw)
+				equals(t, header, tt.want[i].header)
+				equals(t, di.filePath, tt.want[i].filepath)
+			}
+		})
+	}
+}
+
+type wantDiff struct {
+	header   string
+	filepath string
+}
+
+type wantErr struct {
+	header   bool
+	filepath bool
+}
+
+func Test_extract(t *testing.T) {
+	type args struct {
+		in string
+	}
+	tests := []struct {
+		name    string
+		args    args
+		want    wantDiff
+		wantErr wantErr
+	}{
+		{
+			name: "diff.getHeader()",
+			args: args{
+				in: "diff --git a/README.md b/README.md" +
+					"\n" +
+					"index 82366e3..5fc99b9 100644",
+			},
+			want: wantDiff{
+				header:   "diff --git a/README.md b/README.md",
+				filepath: "README.md",
+			},
+			wantErr: wantErr{false, false},
+		},
+		{
+			name: "diff.getHeader()",
+			args: args{
+				in: "diff --git a/TODO.md b/TODO.md" +
+					"\n" +
+					"index 82366e3..5fc99b9 100644",
+			},
+			want: wantDiff{
+				header:   "diff --git a/TODO.md b/TODO.md",
+				filepath: "TODO.md",
+			},
+			wantErr: wantErr{false, false},
+		},
+		{
+			name: "diff.getHeader()",
+			args: args{
+				in: "hello world",
+			},
+			want: wantDiff{
+				header:   "",
+				filepath: "",
+			},
+			wantErr: wantErr{true, true},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			header, errHeader := extractHeader(tt.args.in)
+			equals(t, errHeader != nil, tt.wantErr.header)
+			equals(t, header, tt.want.header)
+			filepath, errFilepath := extractFilePath(tt.args.in)
+			equals(t, errFilepath != nil, tt.wantErr.filepath)
+			equals(t, filepath, tt.want.filepath)
+		})
+	}
+}
diff --git a/diffence b/diffence
index c8b5a84..11d6ebf 100755
Binary files a/diffence and b/diffence differ
diff --git a/lib/check.go b/lib/check.go
deleted file mode 100644
index 8cca068..0000000
--- a/lib/check.go
+++ /dev/null
@@ -1,34 +0,0 @@
-package diffence
-
-import (
-	"io"
-
-	"github.com/y0ssar1an/q"
-)
-
-// Results is hash of results matched for each filepath in a git diff
-// [filepath] => rule{rule1, rule2}
-type Results map[string][]rule
-
-// CheckDiffs is a clean syntax, inefficient way of
-// finding diffs that match the supplied rules
-func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
-	res := Results{}
-	diffs, err := SplitDiffs(r)
-	q.Q(len(diffs))
-	q.Q(err)
-	if err != nil || len(diffs) < 1 {
-		return res, err
-	}
-
-	for _, d := range diffs {
-		res[d.filePath] = []rule{}
-		for _, r := range *rules {
-			if r.Match(d.filePath) {
-				res[d.filePath] = append(res[d.filePath], r)
-			}
-		}
-	}
-
-	return res, err
-}
diff --git a/lib/check_test.go b/lib/check_test.go
deleted file mode 100644
index b647ed8..0000000
--- a/lib/check_test.go
+++ /dev/null
@@ -1,81 +0,0 @@
-package diffence
-
-import (
-	"bytes"
-	"io"
-	"reflect"
-	"testing"
-)
-
-func TestCheckDiffs(t *testing.T) {
-	type args struct {
-		r     io.Reader
-		rules *[]rule
-	}
-
-	ruleSingle := getRuleFile("test/fixtures/rules/rules.json")
-	ruleMulti := getRuleFile("test/fixtures/rules/rules_multi.json")
-
-	tests := []struct {
-		name    string
-		args    args
-		want    Results
-		wantErr bool
-	}{
-		{
-			name: "Recognises an offensive diff",
-			args: args{
-				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
-				rules: ruleSingle,
-			},
-			want: Results{
-				"path/to/password.txt": *ruleSingle,
-			},
-			wantErr: false,
-		},
-		{
-			name: "Recognises an offensive diff",
-			args: args{
-				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
-				rules: ruleMulti,
-			},
-			want: Results{
-				"path/to/password.txt": *ruleSingle,
-			},
-			wantErr: false,
-		},
-		{
-			name: "Recognises an offensive diff",
-			args: args{
-				r:     getFixtureFile("test/fixtures/diffs/multi_fail.diff"),
-				rules: ruleMulti,
-			},
-			want: Results{
-				"path/to/password.txt": []rule{(*ruleMulti)[0]},
-				"another/file/aws.pem": []rule{(*ruleMulti)[1]},
-			},
-			wantErr: false,
-		},
-		{
-			name: "Recognises non diff text",
-			args: args{
-				r:     bytes.NewReader([]byte("not a diff")),
-				rules: ruleMulti,
-			},
-			want:    Results{},
-			wantErr: true,
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got, err := CheckDiffs(tt.args.r, tt.args.rules)
-			if (err != nil) != tt.wantErr {
-				t.Errorf("CheckDiffs() error = %v, wantErr %v", err, tt.wantErr)
-				return
-			}
-			if !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("CheckDiffs() = %v, want %v", got, tt.want)
-			}
-		})
-	}
-}
diff --git a/lib/diff.go b/lib/diff.go
deleted file mode 100644
index 8421e14..0000000
--- a/lib/diff.go
+++ /dev/null
@@ -1,108 +0,0 @@
-package diffence
-
-import (
-	"bufio"
-	"bytes"
-	"fmt"
-	"io"
-	"strings"
-)
-
-// DiffItem is a diff struct for an inidividual file
-type DiffItem struct {
-	raw      string
-	filePath string
-	// addedText string
-	// match        bool
-	// matchedRules []rule
-}
-
-// SplitDiffs splits a single diff txt into an individual DiffItem for each
-// file changed
-func SplitDiffs(r io.Reader) ([]DiffItem, error) {
-
-	var err error
-	scanner := bufio.NewScanner(r)
-	scanner.Split(ScanDiffs)
-
-	// copy to temporary buffer because gets overwritten otherwise
-	// https://golang.org/pkg/bufio/#Scanner.Bytes
-	// "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be OVERWRITTEN by a subsequent call to Scan. It does no allocation."
-	buffer := bytes.NewBuffer(make([]byte, 0))
-	items := []DiffItem{}
-
-	for scanner.Scan() {
-		buffer.Write(scanner.Bytes())
-		raw := buffer.String()
-		filePath, err := extractFilePath(raw)
-		if err != nil {
-			return items, err
-		}
-		items = append(items, DiffItem{
-			raw:      raw,
-			filePath: filePath,
-		})
-		buffer.Reset()
-	}
-
-	if err != nil {
-		return items, err
-	}
-
-	return items, scanner.Err()
-}
-
-// ScanDiffs splits on the diff of an inidividual file
-func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
-	if atEOF && len(data) == 0 {
-		return 0, nil, nil
-	}
-
-	k, nextFileDiffIndex, dataLen := 0, 0, len(data)-1
-	for k < dataLen {
-		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
-			// how far advanced already (k)
-			// index after last \n char (+ i)
-			// start at next byte (+ 1)
-			nextFileDiffIndex = k + i + 1
-			if nextFileDiffIndex < dataLen && string(data[nextFileDiffIndex]) == "d" {
-				return nextFileDiffIndex, dropCR(data[0 : k+i]), nil
-			}
-			k += i + 1
-		} else {
-			k = dataLen
-		}
-	}
-	// If we're at EOF, we have a final, non-terminated line. Return it.
-	if atEOF {
-		return len(data), dropCR(data), nil
-	}
-	// Request more data.
-	return 0, nil, nil
-}
-
-func extractHeader(in string) (string, error) {
-	newLineIndex := strings.Index(in, "\n")
-	if newLineIndex < 0 {
-		return "", fmt.Errorf("not valid diff content:\n\n%s", in)
-	}
-	return in[:newLineIndex], nil
-}
-
-func extractFilePath(in string) (string, error) {
-	prefix := "b/"
-	pathBIndex := strings.Index(in, prefix)
-	newLineIndex := strings.Index(in, "\n")
-	if pathBIndex >= 0 && newLineIndex > pathBIndex {
-		return in[pathBIndex+len(prefix) : newLineIndex], nil
-	}
-	return "", fmt.Errorf("Not valid diff content:\n%s", in)
-}
-
-// dropCR drops a terminal \r from the data.
-func dropCR(data []byte) []byte {
-	if len(data) > 0 && data[len(data)-1] == '\r' {
-		return data[0 : len(data)-1]
-	}
-	return data
-}
diff --git a/lib/diff_test.go b/lib/diff_test.go
deleted file mode 100644
index ac360d9..0000000
--- a/lib/diff_test.go
+++ /dev/null
@@ -1,208 +0,0 @@
-package diffence
-
-import (
-	"bufio"
-	"bytes"
-	"io"
-	"reflect"
-	"testing"
-)
-
-func TestScanDiffsWithBufioScanner(t *testing.T) {
-	type args struct {
-		r io.Reader
-	}
-	tests := []struct {
-		name string
-		args args
-		want [][]byte
-	}{
-		{
-			name: "ScanDiffs() split fn",
-			args: args{r: bytes.NewReader(
-				[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644" +
-						"\n" +
-						"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			)},
-			want: [][]byte{
-				[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-				[]byte(
-					"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got := [][]byte{}
-			scanner := bufio.NewScanner(tt.args.r)
-			scanner.Split(ScanDiffs)
-			for scanner.Scan() {
-				got = append(got, scanner.Bytes())
-			}
-			if !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
-			}
-		})
-	}
-}
-
-func TestSplitDiffs(t *testing.T) {
-	type args struct {
-		r io.Reader
-	}
-
-	tests := []struct {
-		name string
-		args args
-		want []wantDiff
-	}{
-		{
-			name: "Differ.Parse()",
-			args: args{
-				r: getFixtureFile("test/fixtures/diffs/single.diff"),
-			},
-			want: []wantDiff{
-				wantDiff{
-					header:   "diff --git a/README.md b/README.md",
-					filepath: "README.md",
-				},
-			},
-		},
-		{
-			name: "Differ.Parse()",
-			args: args{
-				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
-			},
-			want: []wantDiff{
-				wantDiff{
-					header:   "diff --git a/TODO.md b/TODO.md",
-					filepath: "TODO.md",
-				},
-				wantDiff{
-					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
-					filepath: "systemdlogger/aws.py",
-				},
-				wantDiff{
-					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
-					filepath: "systemdlogger/cloudwatch.py",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
-					filepath: "tests/fixtures/config.json",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
-					filepath: "tests/test_aws.py",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
-					filepath: "tests/test_cloudwatch.py",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
-					filepath: "tests/test_runner_integration.py",
-				},
-			},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-
-			// check for error scanning
-			items, err := SplitDiffs(tt.args.r)
-			if err != nil {
-				t.Fatalf("SplitDiffs threw error %#v", err)
-			}
-
-			// check extracting metadata
-			for i, di := range items {
-				header, _ := extractHeader(di.raw)
-				equals(t, header, tt.want[i].header)
-				equals(t, di.filePath, tt.want[i].filepath)
-			}
-		})
-	}
-}
-
-type wantDiff struct {
-	header   string
-	filepath string
-}
-
-type wantErr struct {
-	header   bool
-	filepath bool
-}
-
-func Test_extract(t *testing.T) {
-	type args struct {
-		in string
-	}
-	tests := []struct {
-		name    string
-		args    args
-		want    wantDiff
-		wantErr wantErr
-	}{
-		{
-			name: "diff.getHeader()",
-			args: args{
-				in: "diff --git a/README.md b/README.md" +
-					"\n" +
-					"index 82366e3..5fc99b9 100644",
-			},
-			want: wantDiff{
-				header:   "diff --git a/README.md b/README.md",
-				filepath: "README.md",
-			},
-			wantErr: wantErr{false, false},
-		},
-		{
-			name: "diff.getHeader()",
-			args: args{
-				in: "diff --git a/TODO.md b/TODO.md" +
-					"\n" +
-					"index 82366e3..5fc99b9 100644",
-			},
-			want: wantDiff{
-				header:   "diff --git a/TODO.md b/TODO.md",
-				filepath: "TODO.md",
-			},
-			wantErr: wantErr{false, false},
-		},
-		{
-			name: "diff.getHeader()",
-			args: args{
-				in: "hello world",
-			},
-			want: wantDiff{
-				header:   "",
-				filepath: "",
-			},
-			wantErr: wantErr{true, true},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			header, errHeader := extractHeader(tt.args.in)
-			equals(t, errHeader != nil, tt.wantErr.header)
-			equals(t, header, tt.want.header)
-			filepath, errFilepath := extractFilePath(tt.args.in)
-			equals(t, errFilepath != nil, tt.wantErr.filepath)
-			equals(t, filepath, tt.want.filepath)
-		})
-	}
-}
diff --git a/lib/rule.go b/lib/rule.go
deleted file mode 100644
index ee60223..0000000
--- a/lib/rule.go
+++ /dev/null
@@ -1,9 +0,0 @@
-package diffence
-
-type rule struct {
-	Caption     string      `'rule':"caption"`
-	Description interface{} `'rule':"description"`
-	Part        string      `'rule':"part"`
-	Pattern     string      `'rule':"pattern"`
-	Type        string      `'rule':"type"`
-}
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
deleted file mode 100644
index b36ad09..0000000
--- a/lib/rule_tmpl.go
+++ /dev/null
@@ -1,54 +0,0 @@
-package diffence
-
-import (
-	"path"
-	"regexp"
-	"strings"
-)
-
-//go:generate gojson -name rule -input ./../test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
-
-////////////////////////////////////////////////////////
-// https://github.com/michenriksen/gitrob#signature-keys
-////////////////////////////////////////////////////////
-const (
-	// RuleTypeRegex is the regex type for pattern matching
-	RuleTypeRegex = "regex"
-
-	// RuleTypeMatch is the string match type for pattern matching
-	RuleTypeMatch = "match"
-)
-
-const (
-	// RulePartPath checks the whole path of the file
-	RulePartPath = "path"
-
-	// RulePartFilename checks the name of the file
-	RulePartFilename = "filename"
-
-	// RulePartExtension checks the extension of the file
-	RulePartExtension = "extension"
-)
-
-// Match runs rules against input strings
-func (r *rule) Match(in string) bool {
-	in = r.extractPart(in)
-	switch r.Type {
-	case RuleTypeRegex:
-		reg := regexp.MustCompile(r.Pattern)
-		return reg.MatchString(in)
-	case RuleTypeMatch:
-		return strings.Contains(in, r.Pattern)
-	}
-	return false
-}
-
-func (r *rule) extractPart(in string) string {
-	switch r.Part {
-	case RulePartFilename:
-		return path.Base(in)
-	case RulePartExtension:
-		return path.Ext(in)
-	}
-	return in
-}
diff --git a/lib/rule_tmpl_test.go b/lib/rule_tmpl_test.go
deleted file mode 100644
index 23028ed..0000000
--- a/lib/rule_tmpl_test.go
+++ /dev/null
@@ -1,109 +0,0 @@
-package diffence
-
-import "testing"
-
-func Test_rule_Match(t *testing.T) {
-	type fields struct {
-		Caption     string
-		Description interface{}
-		Part        string
-		Pattern     string
-		Type        string
-	}
-	type args struct {
-		in string
-	}
-	tests := []struct {
-		name   string
-		fields fields
-		args   args
-		want   bool
-	}{
-		{
-			name: "Should find a match",
-			fields: fields{
-				Caption:     "Contains word: password",
-				Description: nil,
-				Part:        "filename",
-				Pattern:     "password",
-				Type:        "regex",
-			},
-			args: args{"/path/to/password.txt"},
-			want: true,
-		},
-		{
-			name: "Should not find a match (only check filename not preceding path)",
-			fields: fields{
-				Caption:     "Contains word: password",
-				Description: nil,
-				Part:        "filename",
-				Pattern:     "password",
-				Type:        "regex",
-			},
-			args: args{"/path/to/password/file.txt"},
-			want: false,
-		},
-		{
-			name: "Should find a match",
-			fields: fields{
-				Caption:     "Potential cryptographic private key",
-				Description: nil,
-				Part:        "extension",
-				Pattern:     "pem",
-				Type:        "match",
-			},
-			args: args{"/path/to/password.pem"},
-			want: true,
-		},
-		{
-			name: "Should not find a match (only check extension only not preceding path)",
-			fields: fields{
-				Caption:     "Potential cryptographic private key",
-				Description: nil,
-				Part:        "extension",
-				Pattern:     "pem",
-				Type:        "match",
-			},
-			args: args{"/path/to/pem.txt"},
-			want: false,
-		},
-		{
-			name: "Should find a match in extension",
-			fields: fields{
-				Caption:     "Ruby On Rails database schema file",
-				Description: "Contains information on the database schema of a Ruby On Rails application.",
-				Part:        "filename",
-				Pattern:     "schema.rb",
-				Type:        "match",
-			},
-			args: args{"/path/to/schema.rb"},
-			want: true,
-		},
-		{
-			name: "Should not find a match (only check filename not preceding path)",
-			fields: fields{
-				Caption:     "Ruby On Rails database schema file",
-				Description: "Contains information on the database schema of a Ruby On Rails application.",
-				Part:        "filename",
-				Pattern:     "schema.rb",
-				Type:        "match",
-			},
-			args: args{"/path/to/schema.rb/different/file.txt"},
-			want: false,
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			r := &rule{
-				Caption:     tt.fields.Caption,
-				Description: tt.fields.Description,
-				Part:        tt.fields.Part,
-				Pattern:     tt.fields.Pattern,
-				Type:        tt.fields.Type,
-			}
-			if got := r.Match(tt.args.in); got != tt.want {
-				t.Errorf("rule.Match() = %v, want %v", got, tt.want)
-			}
-		})
-	}
-}
diff --git a/lib/rules.go b/lib/rules.go
deleted file mode 100644
index b460c2f..0000000
--- a/lib/rules.go
+++ /dev/null
@@ -1,20 +0,0 @@
-package diffence
-
-import (
-	"encoding/json"
-	"os"
-)
-
-// ReadRulesFromFile reads rules from the local filesystem
-func ReadRulesFromFile(filePath string) (*[]rule, error) {
-	rules := &[]rule{}
-
-	f, err := os.Open(filePath)
-	if err != nil {
-		return rules, err
-	}
-
-	jsonParser := json.NewDecoder(f)
-	err = jsonParser.Decode(rules)
-	return rules, err
-}
diff --git a/lib/rules_test.go b/lib/rules_test.go
deleted file mode 100644
index 13cd9d2..0000000
--- a/lib/rules_test.go
+++ /dev/null
@@ -1,51 +0,0 @@
-package diffence
-
-import (
-	"reflect"
-	"testing"
-)
-
-func Test_readRules(t *testing.T) {
-	type args struct {
-		filePath string
-	}
-	tests := []struct {
-		name    string
-		args    args
-		want    *[]rule
-		wantErr bool
-	}{
-		{
-			name: "Read rules from file",
-			args: args{filePath: "./../test/fixtures/rules/rules.json"},
-			want: &[]rule{
-				{
-					Caption:     "Contains word: password",
-					Description: nil,
-					Part:        "filename",
-					Pattern:     "password",
-					Type:        "regex",
-				},
-			},
-			wantErr: false,
-		},
-		{
-			name:    "Read rules from file",
-			args:    args{filePath: "./../test/fixtures/does_not_exist.json"},
-			want:    &[]rule{},
-			wantErr: true,
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got, err := ReadRulesFromFile(tt.args.filePath)
-			if (err != nil) != tt.wantErr {
-				t.Errorf("ReadRulesFromFile() error = %v, wantErr %v", err, tt.wantErr)
-				return
-			}
-			if !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("ReadRulesFromFile() = %v, want %v", got, tt.want)
-			}
-		})
-	}
-}
diff --git a/lib/testhelpers_test.go b/lib/testhelpers_test.go
deleted file mode 100644
index 8c11fda..0000000
--- a/lib/testhelpers_test.go
+++ /dev/null
@@ -1,55 +0,0 @@
-package diffence
-
-import (
-	"fmt"
-	"io"
-	"os"
-	"path"
-	"path/filepath"
-	"reflect"
-	"runtime"
-	"testing"
-)
-
-func getFixtureFile(filename string) io.Reader {
-	file, err := os.Open(path.Join("../", filename))
-	if err != nil {
-		panic(err)
-	}
-	return file
-}
-
-func getRuleFile(filename string) *[]rule {
-	rules, err := ReadRulesFromFile(path.Join("../", filename))
-	if err != nil {
-		panic(err)
-	}
-	return rules
-}
-
-// assert fails the test if the condition is false.
-func assert(tb testing.TB, condition bool, msg string, v ...interface{}) {
-	if !condition {
-		_, file, line, _ := runtime.Caller(1)
-		fmt.Printf("\033[31m%s:%d: "+msg+"\033[39m\n\n", append([]interface{}{filepath.Base(file), line}, v...)...)
-		tb.FailNow()
-	}
-}
-
-// ok fails the test if an err is not nil.
-func ok(tb testing.TB, err error) {
-	if err != nil {
-		_, file, line, _ := runtime.Caller(1)
-		fmt.Printf("\033[31m%s:%d: unexpected error: %s\033[39m\n\n", filepath.Base(file), line, err.Error())
-		tb.FailNow()
-	}
-}
-
-// equals fails the test if exp is not equal to act.
-func equals(tb testing.TB, exp, act interface{}) {
-	if !reflect.DeepEqual(exp, act) {
-		_, file, line, _ := runtime.Caller(1)
-		fmt.Printf("\033[31m%s:%d:\n\n\texp: %#v\n\n\tgot: %#v\033[39m\n\n", filepath.Base(file), line, exp, act)
-		tb.FailNow()
-	}
-}
diff --git a/rule.go b/rule.go
new file mode 100644
index 0000000..ee60223
--- /dev/null
+++ b/rule.go
@@ -0,0 +1,9 @@
+package diffence
+
+type rule struct {
+	Caption     string      `'rule':"caption"`
+	Description interface{} `'rule':"description"`
+	Part        string      `'rule':"part"`
+	Pattern     string      `'rule':"pattern"`
+	Type        string      `'rule':"type"`
+}
diff --git a/rule_tmpl.go b/rule_tmpl.go
new file mode 100644
index 0000000..b36ad09
--- /dev/null
+++ b/rule_tmpl.go
@@ -0,0 +1,54 @@
+package diffence
+
+import (
+	"path"
+	"regexp"
+	"strings"
+)
+
+//go:generate gojson -name rule -input ./../test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
+
+////////////////////////////////////////////////////////
+// https://github.com/michenriksen/gitrob#signature-keys
+////////////////////////////////////////////////////////
+const (
+	// RuleTypeRegex is the regex type for pattern matching
+	RuleTypeRegex = "regex"
+
+	// RuleTypeMatch is the string match type for pattern matching
+	RuleTypeMatch = "match"
+)
+
+const (
+	// RulePartPath checks the whole path of the file
+	RulePartPath = "path"
+
+	// RulePartFilename checks the name of the file
+	RulePartFilename = "filename"
+
+	// RulePartExtension checks the extension of the file
+	RulePartExtension = "extension"
+)
+
+// Match runs rules against input strings
+func (r *rule) Match(in string) bool {
+	in = r.extractPart(in)
+	switch r.Type {
+	case RuleTypeRegex:
+		reg := regexp.MustCompile(r.Pattern)
+		return reg.MatchString(in)
+	case RuleTypeMatch:
+		return strings.Contains(in, r.Pattern)
+	}
+	return false
+}
+
+func (r *rule) extractPart(in string) string {
+	switch r.Part {
+	case RulePartFilename:
+		return path.Base(in)
+	case RulePartExtension:
+		return path.Ext(in)
+	}
+	return in
+}
diff --git a/rule_tmpl_test.go b/rule_tmpl_test.go
new file mode 100644
index 0000000..23028ed
--- /dev/null
+++ b/rule_tmpl_test.go
@@ -0,0 +1,109 @@
+package diffence
+
+import "testing"
+
+func Test_rule_Match(t *testing.T) {
+	type fields struct {
+		Caption     string
+		Description interface{}
+		Part        string
+		Pattern     string
+		Type        string
+	}
+	type args struct {
+		in string
+	}
+	tests := []struct {
+		name   string
+		fields fields
+		args   args
+		want   bool
+	}{
+		{
+			name: "Should find a match",
+			fields: fields{
+				Caption:     "Contains word: password",
+				Description: nil,
+				Part:        "filename",
+				Pattern:     "password",
+				Type:        "regex",
+			},
+			args: args{"/path/to/password.txt"},
+			want: true,
+		},
+		{
+			name: "Should not find a match (only check filename not preceding path)",
+			fields: fields{
+				Caption:     "Contains word: password",
+				Description: nil,
+				Part:        "filename",
+				Pattern:     "password",
+				Type:        "regex",
+			},
+			args: args{"/path/to/password/file.txt"},
+			want: false,
+		},
+		{
+			name: "Should find a match",
+			fields: fields{
+				Caption:     "Potential cryptographic private key",
+				Description: nil,
+				Part:        "extension",
+				Pattern:     "pem",
+				Type:        "match",
+			},
+			args: args{"/path/to/password.pem"},
+			want: true,
+		},
+		{
+			name: "Should not find a match (only check extension only not preceding path)",
+			fields: fields{
+				Caption:     "Potential cryptographic private key",
+				Description: nil,
+				Part:        "extension",
+				Pattern:     "pem",
+				Type:        "match",
+			},
+			args: args{"/path/to/pem.txt"},
+			want: false,
+		},
+		{
+			name: "Should find a match in extension",
+			fields: fields{
+				Caption:     "Ruby On Rails database schema file",
+				Description: "Contains information on the database schema of a Ruby On Rails application.",
+				Part:        "filename",
+				Pattern:     "schema.rb",
+				Type:        "match",
+			},
+			args: args{"/path/to/schema.rb"},
+			want: true,
+		},
+		{
+			name: "Should not find a match (only check filename not preceding path)",
+			fields: fields{
+				Caption:     "Ruby On Rails database schema file",
+				Description: "Contains information on the database schema of a Ruby On Rails application.",
+				Part:        "filename",
+				Pattern:     "schema.rb",
+				Type:        "match",
+			},
+			args: args{"/path/to/schema.rb/different/file.txt"},
+			want: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			r := &rule{
+				Caption:     tt.fields.Caption,
+				Description: tt.fields.Description,
+				Part:        tt.fields.Part,
+				Pattern:     tt.fields.Pattern,
+				Type:        tt.fields.Type,
+			}
+			if got := r.Match(tt.args.in); got != tt.want {
+				t.Errorf("rule.Match() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/rules.go b/rules.go
new file mode 100644
index 0000000..b460c2f
--- /dev/null
+++ b/rules.go
@@ -0,0 +1,20 @@
+package diffence
+
+import (
+	"encoding/json"
+	"os"
+)
+
+// ReadRulesFromFile reads rules from the local filesystem
+func ReadRulesFromFile(filePath string) (*[]rule, error) {
+	rules := &[]rule{}
+
+	f, err := os.Open(filePath)
+	if err != nil {
+		return rules, err
+	}
+
+	jsonParser := json.NewDecoder(f)
+	err = jsonParser.Decode(rules)
+	return rules, err
+}
diff --git a/rules_test.go b/rules_test.go
new file mode 100644
index 0000000..7cc4fe9
--- /dev/null
+++ b/rules_test.go
@@ -0,0 +1,51 @@
+package diffence
+
+import (
+	"reflect"
+	"testing"
+)
+
+func Test_readRules(t *testing.T) {
+	type args struct {
+		filePath string
+	}
+	tests := []struct {
+		name    string
+		args    args
+		want    *[]rule
+		wantErr bool
+	}{
+		{
+			name: "Read rules from file",
+			args: args{filePath: "test/fixtures/rules/rules.json"},
+			want: &[]rule{
+				{
+					Caption:     "Contains word: password",
+					Description: nil,
+					Part:        "filename",
+					Pattern:     "password",
+					Type:        "regex",
+				},
+			},
+			wantErr: false,
+		},
+		{
+			name:    "Read rules from file",
+			args:    args{filePath: "test/fixtures/does_not_exist.json"},
+			want:    &[]rule{},
+			wantErr: true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := ReadRulesFromFile(tt.args.filePath)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("ReadRulesFromFile() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("ReadRulesFromFile() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/testhelpers_test.go b/testhelpers_test.go
new file mode 100644
index 0000000..c0f1848
--- /dev/null
+++ b/testhelpers_test.go
@@ -0,0 +1,54 @@
+package diffence
+
+import (
+	"fmt"
+	"io"
+	"os"
+	"path/filepath"
+	"reflect"
+	"runtime"
+	"testing"
+)
+
+func getFixtureFile(filename string) io.Reader {
+	file, err := os.Open(filename)
+	if err != nil {
+		panic(err)
+	}
+	return file
+}
+
+func getRuleFile(filename string) *[]rule {
+	rules, err := ReadRulesFromFile(filename)
+	if err != nil {
+		panic(err)
+	}
+	return rules
+}
+
+// assert fails the test if the condition is false.
+func assert(tb testing.TB, condition bool, msg string, v ...interface{}) {
+	if !condition {
+		_, file, line, _ := runtime.Caller(1)
+		fmt.Printf("\033[31m%s:%d: "+msg+"\033[39m\n\n", append([]interface{}{filepath.Base(file), line}, v...)...)
+		tb.FailNow()
+	}
+}
+
+// ok fails the test if an err is not nil.
+func ok(tb testing.TB, err error) {
+	if err != nil {
+		_, file, line, _ := runtime.Caller(1)
+		fmt.Printf("\033[31m%s:%d: unexpected error: %s\033[39m\n\n", filepath.Base(file), line, err.Error())
+		tb.FailNow()
+	}
+}
+
+// equals fails the test if exp is not equal to act.
+func equals(tb testing.TB, exp, act interface{}) {
+	if !reflect.DeepEqual(exp, act) {
+		_, file, line, _ := runtime.Caller(1)
+		fmt.Printf("\033[31m%s:%d:\n\n\texp: %#v\n\n\tgot: %#v\033[39m\n\n", filepath.Base(file), line, exp, act)
+		tb.FailNow()
+	}
+}
ada5423888016f53961c5c12e11a5a807efddf85 Better formatted input error messages for CLI cmd
diff --git a/README.md b/README.md
index 80b226f..45f3e97 100644
--- a/README.md
+++ b/README.md
@@ -2,6 +2,8 @@
 
 Checks a git diff for offensive content.
 
+Golang 1.7+
+
 -----------------------------------------------------------
 
 ## Install CLI tool
diff --git a/TODO.md b/TODO.md
index d8830a0..c0f48dd 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,7 +1,10 @@
 
 export rule
 	-> rename to Rule
-	- re-enable lint githook
+	- re-enable lint githook (disable for that file)
+	- pull request gojson lib - add description flag
+
+move files to root dir
 
 -----------------------------------------------------------
 -----------------------------------------------------------
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index e1ad9b5..9a8a934 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -14,14 +14,14 @@ func main() {
 
 	rules, err := df.ReadRulesFromFile("test/fixtures/rules/gitrob.json")
 	if err != nil {
-		fmt.Printf("\nCannot read rule file:\n%s\n", err)
+		fmt.Printf("\nCannot read rule file: %s\n", err)
 		os.Exit(1)
 		return
 	}
 
 	res, err := df.CheckDiffs(r, rules)
 	if err != nil {
-		fmt.Printf("\nError reading diff:\n%s\n", err)
+		fmt.Printf("\nError reading diff\n%s\n", err)
 		os.Exit(1)
 		return
 	}
diff --git a/diffence b/diffence
index 4c6432e..c8b5a84 100755
Binary files a/diffence and b/diffence differ
diff --git a/lib/diff.go b/lib/diff.go
index 7b7e36c..8421e14 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -96,7 +96,7 @@ func extractFilePath(in string) (string, error) {
 	if pathBIndex >= 0 && newLineIndex > pathBIndex {
 		return in[pathBIndex+len(prefix) : newLineIndex], nil
 	}
-	return "", fmt.Errorf("not valid diff content:\n\n%s", in)
+	return "", fmt.Errorf("Not valid diff content:\n%s", in)
 }
 
 // dropCR drops a terminal \r from the data.
7c727caa5c1289a49238b5b8c7a3d7492e20a6b6 Adds validation for diff content
diff --git a/.overcommit.yml b/.overcommit.yml
index 88ff5c3..8e3408e 100644
--- a/.overcommit.yml
+++ b/.overcommit.yml
@@ -25,7 +25,7 @@ PreCommit:
   # GoLint:
   #   enabled: true
   Lint:
-    enabled: true
+    enabled: false
     required_executable: './bin/githooks/lint.sh'
   Generate:
     enabled: true
diff --git a/Makefile b/Makefile
index 738f5e3..4bb133e 100644
--- a/Makefile
+++ b/Makefile
@@ -25,6 +25,9 @@ run:
 test:
 	@go test ./lib/...
 
+test-cover:
+	@go test -cover ./lib/...
+
 test-race:
 	@go test -race ./lib/...
 
diff --git a/TODO.md b/TODO.md
index ea55865..d8830a0 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,6 +1,10 @@
------------------------------------------------------------
-Add test coverage to Makefile
 
+export rule
+	-> rename to Rule
+	- re-enable lint githook
+
+-----------------------------------------------------------
+-----------------------------------------------------------
 -----------------------------------------------------------
 Add benchmarking
 
@@ -12,7 +16,7 @@ Add concurrency
 
 -----------------------------------------------------------
 Perf
-	- replace map with arrays for diffs + rules
+	- replace map with arrays (not slices) for diffs + rules
 	- move SplitDiffs() into check()
 
 
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index 906ef69..e1ad9b5 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -2,13 +2,28 @@ package main
 
 import (
 	"bytes"
+	"fmt"
+	"os"
 
+	"github.com/kr/pretty"
 	df "github.com/techjacker/diffence/lib"
 )
 
 func main() {
 	r := bytes.NewReader([]byte("hello world"))
-	items, err := df.SplitDiffs(r)
-	println("items", items)
-	println("err", err)
+
+	rules, err := df.ReadRulesFromFile("test/fixtures/rules/gitrob.json")
+	if err != nil {
+		fmt.Printf("\nCannot read rule file:\n%s\n", err)
+		os.Exit(1)
+		return
+	}
+
+	res, err := df.CheckDiffs(r, rules)
+	if err != nil {
+		fmt.Printf("\nError reading diff:\n%s\n", err)
+		os.Exit(1)
+		return
+	}
+	fmt.Printf("%#v\n", pretty.Formatter(res))
 }
diff --git a/diffence b/diffence
index b5f323f..4c6432e 100755
Binary files a/diffence and b/diffence differ
diff --git a/lib/check.go b/lib/check.go
index 171fdaa..8cca068 100644
--- a/lib/check.go
+++ b/lib/check.go
@@ -1,6 +1,10 @@
 package diffence
 
-import "io"
+import (
+	"io"
+
+	"github.com/y0ssar1an/q"
+)
 
 // Results is hash of results matched for each filepath in a git diff
 // [filepath] => rule{rule1, rule2}
@@ -11,7 +15,9 @@ type Results map[string][]rule
 func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
 	res := Results{}
 	diffs, err := SplitDiffs(r)
-	if err != nil {
+	q.Q(len(diffs))
+	q.Q(err)
+	if err != nil || len(diffs) < 1 {
 		return res, err
 	}
 
diff --git a/lib/check_test.go b/lib/check_test.go
index 7eaf239..b647ed8 100644
--- a/lib/check_test.go
+++ b/lib/check_test.go
@@ -1,6 +1,7 @@
 package diffence
 
 import (
+	"bytes"
 	"io"
 	"reflect"
 	"testing"
@@ -55,6 +56,15 @@ func TestCheckDiffs(t *testing.T) {
 			},
 			wantErr: false,
 		},
+		{
+			name: "Recognises non diff text",
+			args: args{
+				r:     bytes.NewReader([]byte("not a diff")),
+				rules: ruleMulti,
+			},
+			want:    Results{},
+			wantErr: true,
+		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
diff --git a/lib/diff.go b/lib/diff.go
index 33922a1..7b7e36c 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -3,6 +3,7 @@ package diffence
 import (
 	"bufio"
 	"bytes"
+	"fmt"
 	"io"
 	"strings"
 )
@@ -20,6 +21,7 @@ type DiffItem struct {
 // file changed
 func SplitDiffs(r io.Reader) ([]DiffItem, error) {
 
+	var err error
 	scanner := bufio.NewScanner(r)
 	scanner.Split(ScanDiffs)
 
@@ -31,13 +33,22 @@ func SplitDiffs(r io.Reader) ([]DiffItem, error) {
 
 	for scanner.Scan() {
 		buffer.Write(scanner.Bytes())
+		raw := buffer.String()
+		filePath, err := extractFilePath(raw)
+		if err != nil {
+			return items, err
+		}
 		items = append(items, DiffItem{
-			raw:      buffer.String(),
-			filePath: extractFilePath(buffer.String()),
+			raw:      raw,
+			filePath: filePath,
 		})
 		buffer.Reset()
 	}
 
+	if err != nil {
+		return items, err
+	}
+
 	return items, scanner.Err()
 }
 
@@ -70,16 +81,22 @@ func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
 	return 0, nil, nil
 }
 
-func extractHeader(in string) string {
+func extractHeader(in string) (string, error) {
 	newLineIndex := strings.Index(in, "\n")
-	return in[:newLineIndex]
+	if newLineIndex < 0 {
+		return "", fmt.Errorf("not valid diff content:\n\n%s", in)
+	}
+	return in[:newLineIndex], nil
 }
 
-func extractFilePath(in string) string {
+func extractFilePath(in string) (string, error) {
 	prefix := "b/"
 	pathBIndex := strings.Index(in, prefix)
 	newLineIndex := strings.Index(in, "\n")
-	return in[pathBIndex+len(prefix) : newLineIndex]
+	if pathBIndex >= 0 && newLineIndex > pathBIndex {
+		return in[pathBIndex+len(prefix) : newLineIndex], nil
+	}
+	return "", fmt.Errorf("not valid diff content:\n\n%s", in)
 }
 
 // dropCR drops a terminal \r from the data.
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 9be8ad0..ac360d9 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -77,7 +77,7 @@ func TestSplitDiffs(t *testing.T) {
 			want: []wantDiff{
 				wantDiff{
 					header:   "diff --git a/README.md b/README.md",
-					filename: "README.md",
+					filepath: "README.md",
 				},
 			},
 		},
@@ -89,31 +89,31 @@ func TestSplitDiffs(t *testing.T) {
 			want: []wantDiff{
 				wantDiff{
 					header:   "diff --git a/TODO.md b/TODO.md",
-					filename: "TODO.md",
+					filepath: "TODO.md",
 				},
 				wantDiff{
 					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
-					filename: "systemdlogger/aws.py",
+					filepath: "systemdlogger/aws.py",
 				},
 				wantDiff{
 					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
-					filename: "systemdlogger/cloudwatch.py",
+					filepath: "systemdlogger/cloudwatch.py",
 				},
 				wantDiff{
 					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
-					filename: "tests/fixtures/config.json",
+					filepath: "tests/fixtures/config.json",
 				},
 				wantDiff{
 					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
-					filename: "tests/test_aws.py",
+					filepath: "tests/test_aws.py",
 				},
 				wantDiff{
 					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
-					filename: "tests/test_cloudwatch.py",
+					filepath: "tests/test_cloudwatch.py",
 				},
 				wantDiff{
 					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
-					filename: "tests/test_runner_integration.py",
+					filepath: "tests/test_runner_integration.py",
 				},
 			},
 		},
@@ -129,8 +129,9 @@ func TestSplitDiffs(t *testing.T) {
 
 			// check extracting metadata
 			for i, di := range items {
-				equals(t, extractHeader(di.raw), tt.want[i].header)
-				equals(t, di.filePath, tt.want[i].filename)
+				header, _ := extractHeader(di.raw)
+				equals(t, header, tt.want[i].header)
+				equals(t, di.filePath, tt.want[i].filepath)
 			}
 		})
 	}
@@ -138,7 +139,12 @@ func TestSplitDiffs(t *testing.T) {
 
 type wantDiff struct {
 	header   string
-	filename string
+	filepath string
+}
+
+type wantErr struct {
+	header   bool
+	filepath bool
 }
 
 func Test_extract(t *testing.T) {
@@ -146,9 +152,10 @@ func Test_extract(t *testing.T) {
 		in string
 	}
 	tests := []struct {
-		name string
-		args args
-		want wantDiff
+		name    string
+		args    args
+		want    wantDiff
+		wantErr wantErr
 	}{
 		{
 			name: "diff.getHeader()",
@@ -159,8 +166,9 @@ func Test_extract(t *testing.T) {
 			},
 			want: wantDiff{
 				header:   "diff --git a/README.md b/README.md",
-				filename: "README.md",
+				filepath: "README.md",
 			},
+			wantErr: wantErr{false, false},
 		},
 		{
 			name: "diff.getHeader()",
@@ -171,14 +179,30 @@ func Test_extract(t *testing.T) {
 			},
 			want: wantDiff{
 				header:   "diff --git a/TODO.md b/TODO.md",
-				filename: "TODO.md",
+				filepath: "TODO.md",
+			},
+			wantErr: wantErr{false, false},
+		},
+		{
+			name: "diff.getHeader()",
+			args: args{
+				in: "hello world",
+			},
+			want: wantDiff{
+				header:   "",
+				filepath: "",
 			},
+			wantErr: wantErr{true, true},
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			equals(t, extractHeader(tt.args.in), tt.want.header)
-			equals(t, extractFilePath(tt.args.in), tt.want.filename)
+			header, errHeader := extractHeader(tt.args.in)
+			equals(t, errHeader != nil, tt.wantErr.header)
+			equals(t, header, tt.want.header)
+			filepath, errFilepath := extractFilePath(tt.args.in)
+			equals(t, errFilepath != nil, tt.wantErr.filepath)
+			equals(t, filepath, tt.want.filepath)
 		})
 	}
 }
diff --git a/lib/rules.go b/lib/rules.go
index 9aadb93..b460c2f 100644
--- a/lib/rules.go
+++ b/lib/rules.go
@@ -5,7 +5,8 @@ import (
 	"os"
 )
 
-func readRulesFromFile(filePath string) (*[]rule, error) {
+// ReadRulesFromFile reads rules from the local filesystem
+func ReadRulesFromFile(filePath string) (*[]rule, error) {
 	rules := &[]rule{}
 
 	f, err := os.Open(filePath)
diff --git a/lib/rules_test.go b/lib/rules_test.go
index caa4fc8..13cd9d2 100644
--- a/lib/rules_test.go
+++ b/lib/rules_test.go
@@ -38,13 +38,13 @@ func Test_readRules(t *testing.T) {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			got, err := readRulesFromFile(tt.args.filePath)
+			got, err := ReadRulesFromFile(tt.args.filePath)
 			if (err != nil) != tt.wantErr {
-				t.Errorf("readRulesFromFile() error = %v, wantErr %v", err, tt.wantErr)
+				t.Errorf("ReadRulesFromFile() error = %v, wantErr %v", err, tt.wantErr)
 				return
 			}
 			if !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("readRulesFromFile() = %v, want %v", got, tt.want)
+				t.Errorf("ReadRulesFromFile() = %v, want %v", got, tt.want)
 			}
 		})
 	}
diff --git a/lib/testhelpers_test.go b/lib/testhelpers_test.go
index 61f8152..8c11fda 100644
--- a/lib/testhelpers_test.go
+++ b/lib/testhelpers_test.go
@@ -20,7 +20,7 @@ func getFixtureFile(filename string) io.Reader {
 }
 
 func getRuleFile(filename string) *[]rule {
-	rules, err := readRulesFromFile(path.Join("../", filename))
+	rules, err := ReadRulesFromFile(path.Join("../", filename))
 	if err != nil {
 		panic(err)
 	}
33e461c447d83599e85c2f6424e730868bf97edc Adds multi rule/diff tests for CheckDiffs()
diff --git a/lib/check_test.go b/lib/check_test.go
index 49b3139..7eaf239 100644
--- a/lib/check_test.go
+++ b/lib/check_test.go
@@ -11,6 +11,10 @@ func TestCheckDiffs(t *testing.T) {
 		r     io.Reader
 		rules *[]rule
 	}
+
+	ruleSingle := getRuleFile("test/fixtures/rules/rules.json")
+	ruleMulti := getRuleFile("test/fixtures/rules/rules_multi.json")
+
 	tests := []struct {
 		name    string
 		args    args
@@ -20,23 +24,34 @@ func TestCheckDiffs(t *testing.T) {
 		{
 			name: "Recognises an offensive diff",
 			args: args{
-				r: getFixtureFile("test/fixtures/diffs/single_fail.diff"),
-				rules: &[]rule{
-					rule{Caption: "Contains word: password",
-						Description: nil,
-						Part:        "filename",
-						Pattern:     "password",
-						Type:        "regex"},
-				},
+				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
+				rules: ruleSingle,
+			},
+			want: Results{
+				"path/to/password.txt": *ruleSingle,
+			},
+			wantErr: false,
+		},
+		{
+			name: "Recognises an offensive diff",
+			args: args{
+				r:     getFixtureFile("test/fixtures/diffs/single_fail.diff"),
+				rules: ruleMulti,
+			},
+			want: Results{
+				"path/to/password.txt": *ruleSingle,
+			},
+			wantErr: false,
+		},
+		{
+			name: "Recognises an offensive diff",
+			args: args{
+				r:     getFixtureFile("test/fixtures/diffs/multi_fail.diff"),
+				rules: ruleMulti,
 			},
 			want: Results{
-				"path/to/password.txt": []rule{
-					rule{Caption: "Contains word: password",
-						Description: nil,
-						Part:        "filename",
-						Pattern:     "password",
-						Type:        "regex"},
-				},
+				"path/to/password.txt": []rule{(*ruleMulti)[0]},
+				"another/file/aws.pem": []rule{(*ruleMulti)[1]},
 			},
 			wantErr: false,
 		},
diff --git a/lib/testhelpers_test.go b/lib/testhelpers_test.go
index 01b3257..61f8152 100644
--- a/lib/testhelpers_test.go
+++ b/lib/testhelpers_test.go
@@ -12,10 +12,21 @@ import (
 )
 
 func getFixtureFile(filename string) io.Reader {
-	file, _ := os.Open(path.Join("../", filename))
+	file, err := os.Open(path.Join("../", filename))
+	if err != nil {
+		panic(err)
+	}
 	return file
 }
 
+func getRuleFile(filename string) *[]rule {
+	rules, err := readRulesFromFile(path.Join("../", filename))
+	if err != nil {
+		panic(err)
+	}
+	return rules
+}
+
 // assert fails the test if the condition is false.
 func assert(tb testing.TB, condition bool, msg string, v ...interface{}) {
 	if !condition {
diff --git a/test/fixtures/diffs/multi_fail.diff b/test/fixtures/diffs/multi_fail.diff
new file mode 100644
index 0000000..b7b305b
--- /dev/null
+++ b/test/fixtures/diffs/multi_fail.diff
@@ -0,0 +1,12 @@
+diff --git a/path/to/password.txt b/path/to/password.txt
+index 82366e3..5fc99b9 100644
+--- a/password.txt
++++ b/password.txt
+@@ -0,0 +1 @@
++illegal
+diff --git a/another/file/aws.pem b/another/file/aws.pem
+index 82366e3..5fc99b9 100644
+--- a/password.txt
++++ b/password.txt
+@@ -0,0 +1 @@
++sdfsdf23432fdsfds325df822922dfwsdfdsf9234324234ffsd344234234
diff --git a/test/fixtures/rules/rules_multi.json b/test/fixtures/rules/rules_multi.json
new file mode 100644
index 0000000..6dbdcef
--- /dev/null
+++ b/test/fixtures/rules/rules_multi.json
@@ -0,0 +1,13 @@
+[{
+	"part": "filename",
+	"type": "regex",
+	"pattern": "password",
+	"caption": "Contains word: password",
+	"description": null
+}, {
+	"part": "extension",
+	"type": "match",
+	"pattern": "pem",
+	"caption": "Potential cryptographic private key",
+	"description": null
+}]
ae851501f74e1d6d7fdfc4144c30c310947cf868 Adds single rule/diff test for CheckDiffs()
diff --git a/TODO.md b/TODO.md
index 5ad12f7..ea55865 100644
--- a/TODO.md
+++ b/TODO.md
@@ -10,7 +10,10 @@ Add concurrency
 	- buffer to max 100?
 		- run benchmark tests (add to tests + makefile)
 
-
+-----------------------------------------------------------
+Perf
+	- replace map with arrays for diffs + rules
+	- move SplitDiffs() into check()
 
 
 
diff --git a/lib/check.go b/lib/check.go
index 395b8a0..171fdaa 100644
--- a/lib/check.go
+++ b/lib/check.go
@@ -6,7 +6,7 @@ import "io"
 // [filepath] => rule{rule1, rule2}
 type Results map[string][]rule
 
-// CheckDiffs is a clean syntax, low memory efficient way of
+// CheckDiffs is a clean syntax, inefficient way of
 // finding diffs that match the supplied rules
 func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
 	res := Results{}
diff --git a/lib/check_test.go b/lib/check_test.go
new file mode 100644
index 0000000..49b3139
--- /dev/null
+++ b/lib/check_test.go
@@ -0,0 +1,56 @@
+package diffence
+
+import (
+	"io"
+	"reflect"
+	"testing"
+)
+
+func TestCheckDiffs(t *testing.T) {
+	type args struct {
+		r     io.Reader
+		rules *[]rule
+	}
+	tests := []struct {
+		name    string
+		args    args
+		want    Results
+		wantErr bool
+	}{
+		{
+			name: "Recognises an offensive diff",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/single_fail.diff"),
+				rules: &[]rule{
+					rule{Caption: "Contains word: password",
+						Description: nil,
+						Part:        "filename",
+						Pattern:     "password",
+						Type:        "regex"},
+				},
+			},
+			want: Results{
+				"path/to/password.txt": []rule{
+					rule{Caption: "Contains word: password",
+						Description: nil,
+						Part:        "filename",
+						Pattern:     "password",
+						Type:        "regex"},
+				},
+			},
+			wantErr: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := CheckDiffs(tt.args.r, tt.args.rules)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("CheckDiffs() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("CheckDiffs() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/test/fixtures/diffs/single_fail.diff b/test/fixtures/diffs/single_fail.diff
new file mode 100644
index 0000000..9dfc51a
--- /dev/null
+++ b/test/fixtures/diffs/single_fail.diff
@@ -0,0 +1,6 @@
+diff --git a/path/to/password.txt b/path/to/password.txt
+index 82366e3..5fc99b9 100644
+--- a/password.txt
++++ b/password.txt
+@@ -0,0 +1 @@
++illegal
fe0e13d9e5cb6d457e07459da9b6404c04825703 Adds FAAS TODO item
diff --git a/Makefile b/Makefile
index 95ef912..738f5e3 100644
--- a/Makefile
+++ b/Makefile
@@ -20,7 +20,7 @@ diff:
 		-H "Accept: application/vnd.github.VERSION.diff"
 
 run:
-	@go build ./cmd/diffence && ./diffence
+	@go build -race ./cmd/diffence && ./diffence
 
 test:
 	@go test ./lib/...
diff --git a/TODO.md b/TODO.md
index 4de3186..5ad12f7 100644
--- a/TODO.md
+++ b/TODO.md
@@ -17,6 +17,9 @@ Add concurrency
 
 -----------------------------------------------------------
 -----------------------------------------------------------
+github integration - HTTP server
+- set up fission on kubernetes
+
 -----------------------------------------------------------
 -----------------------------------------------------------
 
2899d5dec355ce19d2de701893d78fe8aa80b44b Adds CheckDiffs fn
diff --git a/lib/check.go b/lib/check.go
new file mode 100644
index 0000000..395b8a0
--- /dev/null
+++ b/lib/check.go
@@ -0,0 +1,28 @@
+package diffence
+
+import "io"
+
+// Results is hash of results matched for each filepath in a git diff
+// [filepath] => rule{rule1, rule2}
+type Results map[string][]rule
+
+// CheckDiffs is a clean syntax, low memory efficient way of
+// finding diffs that match the supplied rules
+func CheckDiffs(r io.Reader, rules *[]rule) (Results, error) {
+	res := Results{}
+	diffs, err := SplitDiffs(r)
+	if err != nil {
+		return res, err
+	}
+
+	for _, d := range diffs {
+		res[d.filePath] = []rule{}
+		for _, r := range *rules {
+			if r.Match(d.filePath) {
+				res[d.filePath] = append(res[d.filePath], r)
+			}
+		}
+	}
+
+	return res, err
+}
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
index c9116e9..b36ad09 100644
--- a/lib/rule_tmpl.go
+++ b/lib/rule_tmpl.go
@@ -30,8 +30,8 @@ const (
 	RulePartExtension = "extension"
 )
 
-// Run runs rules against input strings
-func (r *rule) Run(in string) bool {
+// Match runs rules against input strings
+func (r *rule) Match(in string) bool {
 	in = r.extractPart(in)
 	switch r.Type {
 	case RuleTypeRegex:
diff --git a/lib/rule_tmpl_test.go b/lib/rule_tmpl_test.go
index 3dca412..23028ed 100644
--- a/lib/rule_tmpl_test.go
+++ b/lib/rule_tmpl_test.go
@@ -2,7 +2,7 @@ package diffence
 
 import "testing"
 
-func Test_rule_Run(t *testing.T) {
+func Test_rule_Match(t *testing.T) {
 	type fields struct {
 		Caption     string
 		Description interface{}
@@ -101,8 +101,8 @@ func Test_rule_Run(t *testing.T) {
 				Pattern:     tt.fields.Pattern,
 				Type:        tt.fields.Type,
 			}
-			if got := r.Run(tt.args.in); got != tt.want {
-				t.Errorf("rule.Run() = %v, want %v", got, tt.want)
+			if got := r.Match(tt.args.in); got != tt.want {
+				t.Errorf("rule.Match() = %v, want %v", got, tt.want)
 			}
 		})
 	}
19eea6f85ed4e9f9c5fb12c1cd913dd43f43069e Moves split into diff file
diff --git a/TODO.md b/TODO.md
index 4ded514..4de3186 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,6 +1,3 @@
-d.getFilename() -> getPath()
-	- move out of struct into separate function
-
 -----------------------------------------------------------
 Add test coverage to Makefile
 
diff --git a/lib/diff.go b/lib/diff.go
index ce9eff2..33922a1 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -1,25 +1,91 @@
 package diffence
 
-import "strings"
+import (
+	"bufio"
+	"bytes"
+	"io"
+	"strings"
+)
 
 // DiffItem is a diff struct for an inidividual file
 type DiffItem struct {
-	raw string
-	// filename  string
+	raw      string
+	filePath string
 	// addedText string
 	// match        bool
 	// matchedRules []rule
 }
 
-// func (d *DiffItem) getHeader() []byte {
-func (d *DiffItem) getHeader() string {
-	newLineIndex := strings.Index(d.raw, "\n")
-	return d.raw[:newLineIndex]
+// SplitDiffs splits a single diff txt into an individual DiffItem for each
+// file changed
+func SplitDiffs(r io.Reader) ([]DiffItem, error) {
+
+	scanner := bufio.NewScanner(r)
+	scanner.Split(ScanDiffs)
+
+	// copy to temporary buffer because gets overwritten otherwise
+	// https://golang.org/pkg/bufio/#Scanner.Bytes
+	// "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be OVERWRITTEN by a subsequent call to Scan. It does no allocation."
+	buffer := bytes.NewBuffer(make([]byte, 0))
+	items := []DiffItem{}
+
+	for scanner.Scan() {
+		buffer.Write(scanner.Bytes())
+		items = append(items, DiffItem{
+			raw:      buffer.String(),
+			filePath: extractFilePath(buffer.String()),
+		})
+		buffer.Reset()
+	}
+
+	return items, scanner.Err()
 }
 
-func (d *DiffItem) getFilename() string {
+// ScanDiffs splits on the diff of an inidividual file
+func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
+	if atEOF && len(data) == 0 {
+		return 0, nil, nil
+	}
+
+	k, nextFileDiffIndex, dataLen := 0, 0, len(data)-1
+	for k < dataLen {
+		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
+			// how far advanced already (k)
+			// index after last \n char (+ i)
+			// start at next byte (+ 1)
+			nextFileDiffIndex = k + i + 1
+			if nextFileDiffIndex < dataLen && string(data[nextFileDiffIndex]) == "d" {
+				return nextFileDiffIndex, dropCR(data[0 : k+i]), nil
+			}
+			k += i + 1
+		} else {
+			k = dataLen
+		}
+	}
+	// If we're at EOF, we have a final, non-terminated line. Return it.
+	if atEOF {
+		return len(data), dropCR(data), nil
+	}
+	// Request more data.
+	return 0, nil, nil
+}
+
+func extractHeader(in string) string {
+	newLineIndex := strings.Index(in, "\n")
+	return in[:newLineIndex]
+}
+
+func extractFilePath(in string) string {
 	prefix := "b/"
-	pathBIndex := strings.Index(d.raw, prefix)
-	newLineIndex := strings.Index(d.raw, "\n")
-	return d.raw[pathBIndex+len(prefix) : newLineIndex]
+	pathBIndex := strings.Index(in, prefix)
+	newLineIndex := strings.Index(in, "\n")
+	return in[pathBIndex+len(prefix) : newLineIndex]
+}
+
+// dropCR drops a terminal \r from the data.
+func dropCR(data []byte) []byte {
+	if len(data) > 0 && data[len(data)-1] == '\r' {
+		return data[0 : len(data)-1]
+	}
+	return data
 }
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 138b656..9be8ad0 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -1,13 +1,147 @@
 package diffence
 
-import "testing"
+import (
+	"bufio"
+	"bytes"
+	"io"
+	"reflect"
+	"testing"
+)
+
+func TestScanDiffsWithBufioScanner(t *testing.T) {
+	type args struct {
+		r io.Reader
+	}
+	tests := []struct {
+		name string
+		args args
+		want [][]byte
+	}{
+		{
+			name: "ScanDiffs() split fn",
+			args: args{r: bytes.NewReader(
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644" +
+						"\n" +
+						"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			)},
+			want: [][]byte{
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+				[]byte(
+					"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := [][]byte{}
+			scanner := bufio.NewScanner(tt.args.r)
+			scanner.Split(ScanDiffs)
+			for scanner.Scan() {
+				got = append(got, scanner.Bytes())
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestSplitDiffs(t *testing.T) {
+	type args struct {
+		r io.Reader
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want []wantDiff
+	}{
+		{
+			name: "Differ.Parse()",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/single.diff"),
+			},
+			want: []wantDiff{
+				wantDiff{
+					header:   "diff --git a/README.md b/README.md",
+					filename: "README.md",
+				},
+			},
+		},
+		{
+			name: "Differ.Parse()",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
+			},
+			want: []wantDiff{
+				wantDiff{
+					header:   "diff --git a/TODO.md b/TODO.md",
+					filename: "TODO.md",
+				},
+				wantDiff{
+					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
+					filename: "systemdlogger/aws.py",
+				},
+				wantDiff{
+					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
+					filename: "systemdlogger/cloudwatch.py",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
+					filename: "tests/fixtures/config.json",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
+					filename: "tests/test_aws.py",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
+					filename: "tests/test_cloudwatch.py",
+				},
+				wantDiff{
+					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
+					filename: "tests/test_runner_integration.py",
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+
+			// check for error scanning
+			items, err := SplitDiffs(tt.args.r)
+			if err != nil {
+				t.Fatalf("SplitDiffs threw error %#v", err)
+			}
+
+			// check extracting metadata
+			for i, di := range items {
+				equals(t, extractHeader(di.raw), tt.want[i].header)
+				equals(t, di.filePath, tt.want[i].filename)
+			}
+		})
+	}
+}
 
 type wantDiff struct {
 	header   string
 	filename string
 }
 
-func Test_extractFileName(t *testing.T) {
+func Test_extract(t *testing.T) {
 	type args struct {
 		in string
 	}
@@ -43,9 +177,8 @@ func Test_extractFileName(t *testing.T) {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			d := DiffItem{tt.args.in}
-			equals(t, d.getHeader(), tt.want.header)
-			equals(t, d.getFilename(), tt.want.filename)
+			equals(t, extractHeader(tt.args.in), tt.want.header)
+			equals(t, extractFilePath(tt.args.in), tt.want.filename)
 		})
 	}
 }
diff --git a/lib/split.go b/lib/split.go
deleted file mode 100644
index 287d14f..0000000
--- a/lib/split.go
+++ /dev/null
@@ -1,66 +0,0 @@
-package diffence
-
-import (
-	"bufio"
-	"bytes"
-	"io"
-)
-
-// SplitDiffs splits a single diff txt into an individual DiffItem for each
-// file changed
-func SplitDiffs(r io.Reader) ([]DiffItem, error) {
-
-	scanner := bufio.NewScanner(r)
-	scanner.Split(ScanDiffs)
-
-	// copy to temporary buffer because gets overwritten otherwise
-	// https://golang.org/pkg/bufio/#Scanner.Bytes
-	// "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be OVERWRITTEN by a subsequent call to Scan. It does no allocation."
-	buffer := bytes.NewBuffer(make([]byte, 0))
-	items := []DiffItem{}
-
-	for scanner.Scan() {
-		buffer.Write(scanner.Bytes())
-		items = append(items, DiffItem{buffer.String()})
-		buffer.Reset()
-	}
-
-	return items, scanner.Err()
-}
-
-// ScanDiffs splits on the diff of an inidividual file
-func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
-	if atEOF && len(data) == 0 {
-		return 0, nil, nil
-	}
-
-	k, nextFileDiffIndex, dataLen := 0, 0, len(data)-1
-	for k < dataLen {
-		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
-			// how far advanced already (k)
-			// index after last \n char (+ i)
-			// start at next byte (+ 1)
-			nextFileDiffIndex = k + i + 1
-			if nextFileDiffIndex < dataLen && string(data[nextFileDiffIndex]) == "d" {
-				return nextFileDiffIndex, dropCR(data[0 : k+i]), nil
-			}
-			k += i + 1
-		} else {
-			k = dataLen
-		}
-	}
-	// If we're at EOF, we have a final, non-terminated line. Return it.
-	if atEOF {
-		return len(data), dropCR(data), nil
-	}
-	// Request more data.
-	return 0, nil, nil
-}
-
-// dropCR drops a terminal \r from the data.
-func dropCR(data []byte) []byte {
-	if len(data) > 0 && data[len(data)-1] == '\r' {
-		return data[0 : len(data)-1]
-	}
-	return data
-}
diff --git a/lib/split_test.go b/lib/split_test.go
deleted file mode 100644
index b40d8f0..0000000
--- a/lib/split_test.go
+++ /dev/null
@@ -1,137 +0,0 @@
-package diffence
-
-import (
-	"bufio"
-	"bytes"
-	"io"
-	"reflect"
-	"testing"
-)
-
-func TestScanDiffsWithBufioScanner(t *testing.T) {
-	type args struct {
-		r io.Reader
-	}
-	tests := []struct {
-		name string
-		args args
-		want [][]byte
-	}{
-		{
-			name: "ScanDiffs() split fn",
-			args: args{r: bytes.NewReader(
-				[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644" +
-						"\n" +
-						"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			)},
-			want: [][]byte{
-				[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-				[]byte(
-					"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got := [][]byte{}
-			scanner := bufio.NewScanner(tt.args.r)
-			scanner.Split(ScanDiffs)
-			for scanner.Scan() {
-				got = append(got, scanner.Bytes())
-			}
-			if !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
-			}
-		})
-	}
-}
-
-func Test_diff_Parse(t *testing.T) {
-	type args struct {
-		r io.Reader
-	}
-
-	tests := []struct {
-		name string
-		args args
-		want []wantDiff
-	}{
-		{
-			name: "Differ.Parse()",
-			args: args{
-				r: getFixtureFile("test/fixtures/diffs/single.diff"),
-			},
-			want: []wantDiff{
-				wantDiff{
-					header:   "diff --git a/README.md b/README.md",
-					filename: "README.md",
-				},
-			},
-		},
-		{
-			name: "Differ.Parse()",
-			args: args{
-				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
-			},
-			want: []wantDiff{
-				wantDiff{
-					header:   "diff --git a/TODO.md b/TODO.md",
-					filename: "TODO.md",
-				},
-				wantDiff{
-					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
-					filename: "systemdlogger/aws.py",
-				},
-				wantDiff{
-					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
-					filename: "systemdlogger/cloudwatch.py",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
-					filename: "tests/fixtures/config.json",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
-					filename: "tests/test_aws.py",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
-					filename: "tests/test_cloudwatch.py",
-				},
-				wantDiff{
-					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
-					filename: "tests/test_runner_integration.py",
-				},
-			},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-
-			// check for error scanning
-			items, err := SplitDiffs(tt.args.r)
-			if err != nil {
-				t.Fatalf("SplitDiffs threw error %#v", err)
-			}
-
-			// check extracting metadata
-			for i, di := range items {
-				equals(t, di.getHeader(), tt.want[i].header)
-				equals(t, di.getFilename(), tt.want[i].filename)
-			}
-		})
-	}
-}
c4eafa9501154f5a02fcaaadae5c2c55a4019d46 Extracts part of filepath before matching vs rule
diff --git a/TODO.md b/TODO.md
index f173588..4ded514 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,9 +1,11 @@
-
-
 d.getFilename() -> getPath()
 	- move out of struct into separate function
 
+-----------------------------------------------------------
+Add test coverage to Makefile
 
+-----------------------------------------------------------
+Add benchmarking
 
 -----------------------------------------------------------
 Add concurrency
@@ -11,17 +13,29 @@ Add concurrency
 	- buffer to max 100?
 		- run benchmark tests (add to tests + makefile)
 
+
+
+
+
+
+-----------------------------------------------------------
+-----------------------------------------------------------
+-----------------------------------------------------------
 -----------------------------------------------------------
 
 return just error from main function (vs bool, error)
 
+-----------------------------------------------------------
+
 add logger
 
 -----------------------------------------------------------
 add build task -> convert JSON rules into golang struct
 	- make part of dockerfile?
 
+-----------------------------------------------------------
 add multiple rules files to be inputed
 	bufio.MultiReader
 
+-----------------------------------------------------------
 set up realize - live reload run tests etc
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
index f885f97..c9116e9 100644
--- a/lib/rule_tmpl.go
+++ b/lib/rule_tmpl.go
@@ -1,6 +1,7 @@
 package diffence
 
 import (
+	"path"
 	"regexp"
 	"strings"
 )
@@ -13,39 +14,25 @@ import (
 const (
 	// RuleTypeRegex is the regex type for pattern matching
 	RuleTypeRegex = "regex"
-	// regex: Regular expression matching of part and pattern
-	// https://golang.org/pkg/regexp/#Regexp.FindAllString
-	// re := regexp.MustCompile("a.")
-	// fmt.Println(re.FindAllString("paranormal", -1))
-	// matched, err := regexp.MatchString("foo.*", "seafood")
-	// fmt.Println(matched, err)
 
 	// RuleTypeMatch is the string match type for pattern matching
 	RuleTypeMatch = "match"
-	// match: Simple match of part and pattern
-	// strings.Contains("seafood", "foo")
-	// https://golang.org/pkg/regexp/#Regexp.MatchString
-	// https://golang.org/pkg/regexp/#Regexp.Match
 )
 
 const (
-	// RulePartPath checks the path of the file
+	// RulePartPath checks the whole path of the file
 	RulePartPath = "path"
-	// complete file path
-	// Only the file extension
 
 	// RulePartFilename checks the name of the file
 	RulePartFilename = "filename"
-	// Only the filename
-	// path.Base()
 
 	// RulePartExtension checks the extension of the file
 	RulePartExtension = "extension"
-	// path.Ext()
 )
 
 // Run runs rules against input strings
 func (r *rule) Run(in string) bool {
+	in = r.extractPart(in)
 	switch r.Type {
 	case RuleTypeRegex:
 		reg := regexp.MustCompile(r.Pattern)
@@ -55,3 +42,13 @@ func (r *rule) Run(in string) bool {
 	}
 	return false
 }
+
+func (r *rule) extractPart(in string) string {
+	switch r.Part {
+	case RulePartFilename:
+		return path.Base(in)
+	case RulePartExtension:
+		return path.Ext(in)
+	}
+	return in
+}
diff --git a/lib/rule_tmpl_test.go b/lib/rule_tmpl_test.go
index efd8739..3dca412 100644
--- a/lib/rule_tmpl_test.go
+++ b/lib/rule_tmpl_test.go
@@ -31,6 +31,66 @@ func Test_rule_Run(t *testing.T) {
 			args: args{"/path/to/password.txt"},
 			want: true,
 		},
+		{
+			name: "Should not find a match (only check filename not preceding path)",
+			fields: fields{
+				Caption:     "Contains word: password",
+				Description: nil,
+				Part:        "filename",
+				Pattern:     "password",
+				Type:        "regex",
+			},
+			args: args{"/path/to/password/file.txt"},
+			want: false,
+		},
+		{
+			name: "Should find a match",
+			fields: fields{
+				Caption:     "Potential cryptographic private key",
+				Description: nil,
+				Part:        "extension",
+				Pattern:     "pem",
+				Type:        "match",
+			},
+			args: args{"/path/to/password.pem"},
+			want: true,
+		},
+		{
+			name: "Should not find a match (only check extension only not preceding path)",
+			fields: fields{
+				Caption:     "Potential cryptographic private key",
+				Description: nil,
+				Part:        "extension",
+				Pattern:     "pem",
+				Type:        "match",
+			},
+			args: args{"/path/to/pem.txt"},
+			want: false,
+		},
+		{
+			name: "Should find a match in extension",
+			fields: fields{
+				Caption:     "Ruby On Rails database schema file",
+				Description: "Contains information on the database schema of a Ruby On Rails application.",
+				Part:        "filename",
+				Pattern:     "schema.rb",
+				Type:        "match",
+			},
+			args: args{"/path/to/schema.rb"},
+			want: true,
+		},
+		{
+			name: "Should not find a match (only check filename not preceding path)",
+			fields: fields{
+				Caption:     "Ruby On Rails database schema file",
+				Description: "Contains information on the database schema of a Ruby On Rails application.",
+				Part:        "filename",
+				Pattern:     "schema.rb",
+				Type:        "match",
+			},
+			args: args{"/path/to/schema.rb/different/file.txt"},
+			want: false,
+		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
f27712711303123eeff4996878ac2d74f2771172 Adds initial rule.Run() test
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
index a3af312..f885f97 100644
--- a/lib/rule_tmpl.go
+++ b/lib/rule_tmpl.go
@@ -1,7 +1,6 @@
 package diffence
 
 import (
-	"fmt"
 	"regexp"
 	"strings"
 )
@@ -45,44 +44,14 @@ const (
 	// path.Ext()
 )
 
-// RuleResult returns the result of the pattern matching
-type RuleResult struct {
-	Matched bool
-	Err     error
-}
-
-//////////////
-// pattern: (match = string)
-// regular expression to match with
-//////////////
-func (r *rule) Run(in string) RuleResult {
+// Run runs rules against input strings
+func (r *rule) Run(in string) bool {
 	switch r.Type {
 	case RuleTypeRegex:
-		return r.runRegex(in)
+		reg := regexp.MustCompile(r.Pattern)
+		return reg.MatchString(in)
 	case RuleTypeMatch:
-		return r.runMatch(in)
-	}
-	return RuleResult{
-		Matched: false,
-		Err:     fmt.Errorf("Unrecognised rule type: %s", r.Type),
-	}
-}
-
-func (r *rule) runRegex(in string) RuleResult {
-	var matched bool
-	reg, err := regexp.Compile(r.Pattern)
-	if err != nil {
-		matched = reg.MatchString(in)
-	}
-	return RuleResult{
-		Matched: matched,
-		Err:     err,
-	}
-}
-
-func (r *rule) runMatch(in string) RuleResult {
-	return RuleResult{
-		Matched: strings.Contains(in, r.Pattern),
-		Err:     nil,
+		return strings.Contains(in, r.Pattern)
 	}
+	return false
 }
diff --git a/lib/rule_tmpl_test.go b/lib/rule_tmpl_test.go
new file mode 100644
index 0000000..efd8739
--- /dev/null
+++ b/lib/rule_tmpl_test.go
@@ -0,0 +1,49 @@
+package diffence
+
+import "testing"
+
+func Test_rule_Run(t *testing.T) {
+	type fields struct {
+		Caption     string
+		Description interface{}
+		Part        string
+		Pattern     string
+		Type        string
+	}
+	type args struct {
+		in string
+	}
+	tests := []struct {
+		name   string
+		fields fields
+		args   args
+		want   bool
+	}{
+		{
+			name: "Should find a match",
+			fields: fields{
+				Caption:     "Contains word: password",
+				Description: nil,
+				Part:        "filename",
+				Pattern:     "password",
+				Type:        "regex",
+			},
+			args: args{"/path/to/password.txt"},
+			want: true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			r := &rule{
+				Caption:     tt.fields.Caption,
+				Description: tt.fields.Description,
+				Part:        tt.fields.Part,
+				Pattern:     tt.fields.Pattern,
+				Type:        tt.fields.Type,
+			}
+			if got := r.Run(tt.args.in); got != tt.want {
+				t.Errorf("rule.Run() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/lib/rules_test.go b/lib/rules_test.go
index 1154454..caa4fc8 100644
--- a/lib/rules_test.go
+++ b/lib/rules_test.go
@@ -20,11 +20,11 @@ func Test_readRules(t *testing.T) {
 			args: args{filePath: "./../test/fixtures/rules/rules.json"},
 			want: &[]rule{
 				{
-					Part:        "filename",
-					Type:        "regex",
-					Pattern:     "password",
 					Caption:     "Contains word: password",
 					Description: nil,
+					Part:        "filename",
+					Pattern:     "password",
+					Type:        "regex",
 				},
 			},
 			wantErr: false,
diff --git a/lib/testhelpers_test.go b/lib/testhelpers_test.go
index d7f227e..01b3257 100644
--- a/lib/testhelpers_test.go
+++ b/lib/testhelpers_test.go
@@ -3,7 +3,6 @@ package diffence
 import (
 	"fmt"
 	"io"
-	"log"
 	"os"
 	"path"
 	"path/filepath"
@@ -13,11 +12,7 @@ import (
 )
 
 func getFixtureFile(filename string) io.Reader {
-	cwd, _ := os.Getwd()
-	file, err := os.Open(path.Join(cwd, "../", filename))
-	if err != nil {
-		log.Fatal(err)
-	}
+	file, _ := os.Open(path.Join("../", filename))
 	return file
 }
 
5cb1753cf2377fec293e1abfc7c09f7252203cda Lints rule_tmpl.go
diff --git a/.overcommit.yml b/.overcommit.yml
index 0002b90..88ff5c3 100644
--- a/.overcommit.yml
+++ b/.overcommit.yml
@@ -18,6 +18,10 @@
 PreCommit:
   GoVet:
     enabled: true
+  Test:
+    enabled: true
+    required_executable: './bin/githooks/test.sh'
+  # disabled because returns false positives -> replaced with shell script below
   # GoLint:
   #   enabled: true
   Lint:
diff --git a/Makefile b/Makefile
index c438ccd..95ef912 100644
--- a/Makefile
+++ b/Makefile
@@ -7,7 +7,7 @@ RULES_URL = https://raw.githubusercontent.com/michenriksen/gitrob/master/signatu
 
 
 lint:
-	@golint ./...
+	@golint  -set_exit_status ./...
 	@go vet ./...
 	@interfacer $(go list ./... | grep -v /vendor/)
 
@@ -23,10 +23,10 @@ run:
 	@go build ./cmd/diffence && ./diffence
 
 test:
-	@go test ./...
+	@go test ./lib/...
 
 test-race:
-	@go test -race ./...
+	@go test -race ./lib/...
 
 
 .PHONY: test run
diff --git a/bin/githooks/lint.sh b/bin/githooks/lint.sh
index c6dd63d..b178974 100755
--- a/bin/githooks/lint.sh
+++ b/bin/githooks/lint.sh
@@ -1,3 +1,3 @@
 #!/bin/bash
 
-golint ./...
+golint -set_exit_status ./...
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
index 34598f1..a3af312 100644
--- a/lib/rule_tmpl.go
+++ b/lib/rule_tmpl.go
@@ -11,36 +11,41 @@ import (
 ////////////////////////////////////////////////////////
 // https://github.com/michenriksen/gitrob#signature-keys
 ////////////////////////////////////////////////////////
-type RuleType string
-
 const (
+	// RuleTypeRegex is the regex type for pattern matching
+	RuleTypeRegex = "regex"
 	// regex: Regular expression matching of part and pattern
 	// https://golang.org/pkg/regexp/#Regexp.FindAllString
 	// re := regexp.MustCompile("a.")
 	// fmt.Println(re.FindAllString("paranormal", -1))
 	// matched, err := regexp.MatchString("foo.*", "seafood")
 	// fmt.Println(matched, err)
-	REGEX RuleType = "regex"
+
+	// RuleTypeMatch is the string match type for pattern matching
+	RuleTypeMatch = "match"
 	// match: Simple match of part and pattern
 	// strings.Contains("seafood", "foo")
 	// https://golang.org/pkg/regexp/#Regexp.MatchString
 	// https://golang.org/pkg/regexp/#Regexp.Match
-	MATCH RuleType = "match"
 )
 
-type RulePart string
-
 const (
+	// RulePartPath checks the path of the file
+	RulePartPath = "path"
 	// complete file path
-	PATH RulePart = "part"
+	// Only the file extension
+
+	// RulePartFilename checks the name of the file
+	RulePartFilename = "filename"
 	// Only the filename
 	// path.Base()
-	FILENAME = "filename"
-	// Only the file extension
+
+	// RulePartExtension checks the extension of the file
+	RulePartExtension = "extension"
 	// path.Ext()
-	EXTENSION = "extension"
 )
 
+// RuleResult returns the result of the pattern matching
 type RuleResult struct {
 	Matched bool
 	Err     error
@@ -52,9 +57,9 @@ type RuleResult struct {
 //////////////
 func (r *rule) Run(in string) RuleResult {
 	switch r.Type {
-	case REGEX:
+	case RuleTypeRegex:
 		return r.runRegex(in)
-	case MATCH:
+	case RuleTypeMatch:
 		return r.runMatch(in)
 	}
 	return RuleResult{
@@ -64,9 +69,11 @@ func (r *rule) Run(in string) RuleResult {
 }
 
 func (r *rule) runRegex(in string) RuleResult {
-	reg := regexp.MustCompile(r.Pattern)
-	matched, err := reg.MatchString(in)
-
+	var matched bool
+	reg, err := regexp.Compile(r.Pattern)
+	if err != nil {
+		matched = reg.MatchString(in)
+	}
 	return RuleResult{
 		Matched: matched,
 		Err:     err,
@@ -76,6 +83,6 @@ func (r *rule) runRegex(in string) RuleResult {
 func (r *rule) runMatch(in string) RuleResult {
 	return RuleResult{
 		Matched: strings.Contains(in, r.Pattern),
-		Err:     err,
+		Err:     nil,
 	}
 }
03e047148fa187c183c22b8ef874f6cff1c6d534 Stubs rule match methods
diff --git a/TODO.md b/TODO.md
index 423aa0b..f173588 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,18 +1,11 @@
-Convert extract to lexer
-	- make accept io.Reader (not bytes as arg)
 
-Add more tests
-	- extract_test (/lexer_test)
-		- filename
-		- addedText
-	- diff_test
-		- multi diff test expectations
-		- add more diff fixture files
 
------------------------------------------------------------
-Make rules struct private
-	- add getter for channels to access
+d.getFilename() -> getPath()
+	- move out of struct into separate function
+
 
+
+-----------------------------------------------------------
 Add concurrency
 	- each NewDiffItem = new go routine
 	- buffer to max 100?
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
index 948c851..34598f1 100644
--- a/lib/rule_tmpl.go
+++ b/lib/rule_tmpl.go
@@ -1,31 +1,81 @@
 package diffence
 
+import (
+	"fmt"
+	"regexp"
+	"strings"
+)
+
 //go:generate gojson -name rule -input ./../test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
 
-//
+////////////////////////////////////////////////////////
 // https://github.com/michenriksen/gitrob#signature-keys
-//
-//////////////
-// part
-//////////////
-// path: The complete file path
+////////////////////////////////////////////////////////
+type RuleType string
 
-// filename: Only the filename
-// path.Base()
+const (
+	// regex: Regular expression matching of part and pattern
+	// https://golang.org/pkg/regexp/#Regexp.FindAllString
+	// re := regexp.MustCompile("a.")
+	// fmt.Println(re.FindAllString("paranormal", -1))
+	// matched, err := regexp.MatchString("foo.*", "seafood")
+	// fmt.Println(matched, err)
+	REGEX RuleType = "regex"
+	// match: Simple match of part and pattern
+	// strings.Contains("seafood", "foo")
+	// https://golang.org/pkg/regexp/#Regexp.MatchString
+	// https://golang.org/pkg/regexp/#Regexp.Match
+	MATCH RuleType = "match"
+)
 
-// extension: Only the file extension
-// path.Ext()
+type RulePart string
 
-//////////////
-// type
-//////////////
-// match: Simple match of part and pattern
-// strings.Contains("seafood", "foo")
+const (
+	// complete file path
+	PATH RulePart = "part"
+	// Only the filename
+	// path.Base()
+	FILENAME = "filename"
+	// Only the file extension
+	// path.Ext()
+	EXTENSION = "extension"
+)
 
-// regex: Regular expression matching of part and pattern
+type RuleResult struct {
+	Matched bool
+	Err     error
+}
 
 //////////////
-// pattern: The value or regular expression to match with
+// pattern: (match = string)
+// regular expression to match with
 //////////////
+func (r *rule) Run(in string) RuleResult {
+	switch r.Type {
+	case REGEX:
+		return r.runRegex(in)
+	case MATCH:
+		return r.runMatch(in)
+	}
+	return RuleResult{
+		Matched: false,
+		Err:     fmt.Errorf("Unrecognised rule type: %s", r.Type),
+	}
+}
+
+func (r *rule) runRegex(in string) RuleResult {
+	reg := regexp.MustCompile(r.Pattern)
+	matched, err := reg.MatchString(in)
+
+	return RuleResult{
+		Matched: matched,
+		Err:     err,
+	}
+}
 
-// func(r rule) () {
+func (r *rule) runMatch(in string) RuleResult {
+	return RuleResult{
+		Matched: strings.Contains(in, r.Pattern),
+		Err:     err,
+	}
+}
a907c7b2ee5865b4d36a3ec2da95c38408e5d7a0 Adds test helpers
diff --git a/README.md b/README.md
index ef4fcf6..80b226f 100644
--- a/README.md
+++ b/README.md
@@ -21,6 +21,12 @@ go get -u github.com/techjacker/diffence/cmd/diffence
 ```
 ```
 
+-----------------------------------------------------------
+## [Gitrob Rules - Signature Keys](https://github.com/michenriksen/gitrob#signature-keys)
+
+
+
+
 
 -----------------------------------------------------------
 ## JSON Configuration
diff --git a/lib/diff.go b/lib/diff.go
index 3a042d6..ce9eff2 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -17,14 +17,9 @@ func (d *DiffItem) getHeader() string {
 	return d.raw[:newLineIndex]
 }
 
-// func (d *DiffItem) getFilename() []byte {
-// 	// prefix := []byte("diff --git a/")
-// 	// firstLine := bytes.SplitN(in, []byte)
-// 	newLineIndex := bytes.IndexByte(d.raw, '\n')
-// 	indexfilePrefix := bytes.LastIndexFunc(
-// 		d.raw[0:newLineIndex],
-// 		unicode.IsSpace,
-// 	)
-// 	prefix := d.raw[indexfilePrefix+1 : newLineIndex]
-// 	return bytes.TrimPrefix(prefix, []byte("b/"))
-// }
+func (d *DiffItem) getFilename() string {
+	prefix := "b/"
+	pathBIndex := strings.Index(d.raw, prefix)
+	newLineIndex := strings.Index(d.raw, "\n")
+	return d.raw[pathBIndex+len(prefix) : newLineIndex]
+}
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 6b0afbd..138b656 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -1,22 +1,20 @@
 package diffence
 
-import (
-	"reflect"
-	"testing"
-)
+import "testing"
+
+type wantDiff struct {
+	header   string
+	filename string
+}
 
 func Test_extractFileName(t *testing.T) {
 	type args struct {
 		in string
 	}
-	type want struct {
-		header   string
-		filename string
-	}
 	tests := []struct {
 		name string
 		args args
-		want want
+		want wantDiff
 	}{
 		{
 			name: "diff.getHeader()",
@@ -25,7 +23,7 @@ func Test_extractFileName(t *testing.T) {
 					"\n" +
 					"index 82366e3..5fc99b9 100644",
 			},
-			want: want{
+			want: wantDiff{
 				header:   "diff --git a/README.md b/README.md",
 				filename: "README.md",
 			},
@@ -37,7 +35,7 @@ func Test_extractFileName(t *testing.T) {
 					"\n" +
 					"index 82366e3..5fc99b9 100644",
 			},
-			want: want{
+			want: wantDiff{
 				header:   "diff --git a/TODO.md b/TODO.md",
 				filename: "TODO.md",
 			},
@@ -46,9 +44,8 @@ func Test_extractFileName(t *testing.T) {
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			d := DiffItem{tt.args.in}
-			if got := d.getHeader(); !reflect.DeepEqual(got, tt.want.header) {
-				t.Errorf("d.getHeader()\nGOT:%s\nWANT:%s", got, tt.want.header)
-			}
+			equals(t, d.getHeader(), tt.want.header)
+			equals(t, d.getFilename(), tt.want.filename)
 		})
 	}
 }
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
index ecb1ff2..948c851 100644
--- a/lib/rule_tmpl.go
+++ b/lib/rule_tmpl.go
@@ -1,3 +1,31 @@
 package diffence
 
 //go:generate gojson -name rule -input ./../test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
+
+//
+// https://github.com/michenriksen/gitrob#signature-keys
+//
+//////////////
+// part
+//////////////
+// path: The complete file path
+
+// filename: Only the filename
+// path.Base()
+
+// extension: Only the file extension
+// path.Ext()
+
+//////////////
+// type
+//////////////
+// match: Simple match of part and pattern
+// strings.Contains("seafood", "foo")
+
+// regex: Regular expression matching of part and pattern
+
+//////////////
+// pattern: The value or regular expression to match with
+//////////////
+
+// func(r rule) () {
diff --git a/lib/split_test.go b/lib/split_test.go
index 7ede384..b40d8f0 100644
--- a/lib/split_test.go
+++ b/lib/split_test.go
@@ -4,9 +4,6 @@ import (
 	"bufio"
 	"bytes"
 	"io"
-	"log"
-	"os"
-	"path"
 	"reflect"
 	"testing"
 )
@@ -62,37 +59,25 @@ func TestScanDiffsWithBufioScanner(t *testing.T) {
 	}
 }
 
-func getFixtureFile(filename string) io.Reader {
-	cwd, _ := os.Getwd()
-	file, err := os.Open(path.Join(cwd, "../", filename))
-	if err != nil {
-		log.Fatal(err)
-	}
-	return file
-}
-
 func Test_diff_Parse(t *testing.T) {
 	type args struct {
 		r io.Reader
 	}
-	type want struct {
-		header   string
-		filename []byte
-	}
+
 	tests := []struct {
 		name string
 		args args
-		want []want
+		want []wantDiff
 	}{
 		{
 			name: "Differ.Parse()",
 			args: args{
 				r: getFixtureFile("test/fixtures/diffs/single.diff"),
 			},
-			want: []want{
-				want{
+			want: []wantDiff{
+				wantDiff{
 					header:   "diff --git a/README.md b/README.md",
-					filename: []byte("README.md"),
+					filename: "README.md",
 				},
 			},
 		},
@@ -101,34 +86,34 @@ func Test_diff_Parse(t *testing.T) {
 			args: args{
 				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
 			},
-			want: []want{
-				want{
+			want: []wantDiff{
+				wantDiff{
 					header:   "diff --git a/TODO.md b/TODO.md",
-					filename: []byte("TODO.md"),
+					filename: "TODO.md",
 				},
-				want{
+				wantDiff{
 					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
-					filename: []byte("systemdlogger/aws.py"),
+					filename: "systemdlogger/aws.py",
 				},
-				want{
+				wantDiff{
 					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
-					filename: []byte("systemdlogger/cloudwatch.py"),
+					filename: "systemdlogger/cloudwatch.py",
 				},
-				want{
+				wantDiff{
 					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
-					filename: []byte("tests/fixtures/config.json"),
+					filename: "tests/fixtures/config.json",
 				},
-				want{
+				wantDiff{
 					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
-					filename: []byte("tests/test_aws.py"),
+					filename: "tests/test_aws.py",
 				},
-				want{
+				wantDiff{
 					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
-					filename: []byte("tests/test_cloudwatch.py"),
+					filename: "tests/test_cloudwatch.py",
 				},
-				want{
+				wantDiff{
 					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
-					filename: []byte("tests/test_runner_integration.py"),
+					filename: "tests/test_runner_integration.py",
 				},
 			},
 		},
@@ -144,10 +129,8 @@ func Test_diff_Parse(t *testing.T) {
 
 			// check extracting metadata
 			for i, di := range items {
-				if tt.want[i].header != di.getHeader() {
-					t.Errorf("SplitDiffs() item:%d \nWANT: %s\nGOT: %s", i, tt.want[i].header, di.getHeader())
-					t.Fatalf("Body:\n\n%s", di.raw)
-				}
+				equals(t, di.getHeader(), tt.want[i].header)
+				equals(t, di.getFilename(), tt.want[i].filename)
 			}
 		})
 	}
diff --git a/lib/testhelpers_test.go b/lib/testhelpers_test.go
new file mode 100644
index 0000000..d7f227e
--- /dev/null
+++ b/lib/testhelpers_test.go
@@ -0,0 +1,49 @@
+package diffence
+
+import (
+	"fmt"
+	"io"
+	"log"
+	"os"
+	"path"
+	"path/filepath"
+	"reflect"
+	"runtime"
+	"testing"
+)
+
+func getFixtureFile(filename string) io.Reader {
+	cwd, _ := os.Getwd()
+	file, err := os.Open(path.Join(cwd, "../", filename))
+	if err != nil {
+		log.Fatal(err)
+	}
+	return file
+}
+
+// assert fails the test if the condition is false.
+func assert(tb testing.TB, condition bool, msg string, v ...interface{}) {
+	if !condition {
+		_, file, line, _ := runtime.Caller(1)
+		fmt.Printf("\033[31m%s:%d: "+msg+"\033[39m\n\n", append([]interface{}{filepath.Base(file), line}, v...)...)
+		tb.FailNow()
+	}
+}
+
+// ok fails the test if an err is not nil.
+func ok(tb testing.TB, err error) {
+	if err != nil {
+		_, file, line, _ := runtime.Caller(1)
+		fmt.Printf("\033[31m%s:%d: unexpected error: %s\033[39m\n\n", filepath.Base(file), line, err.Error())
+		tb.FailNow()
+	}
+}
+
+// equals fails the test if exp is not equal to act.
+func equals(tb testing.TB, exp, act interface{}) {
+	if !reflect.DeepEqual(exp, act) {
+		_, file, line, _ := runtime.Caller(1)
+		fmt.Printf("\033[31m%s:%d:\n\n\texp: %#v\n\n\tgot: %#v\033[39m\n\n", filepath.Base(file), line, exp, act)
+		tb.FailNow()
+	}
+}
e52e7701a5769fbe5fefb610e07ce2b539ff46b5 Adds lint git hook
diff --git a/.overcommit.yml b/.overcommit.yml
index 1b01598..0002b90 100644
--- a/.overcommit.yml
+++ b/.overcommit.yml
@@ -18,8 +18,11 @@
 PreCommit:
   GoVet:
     enabled: true
-  GoLint:
+  # GoLint:
+  #   enabled: true
+  Lint:
     enabled: true
+    required_executable: './bin/githooks/lint.sh'
   Generate:
     enabled: true
     required_executable: './bin/githooks/generate.sh'
diff --git a/bin/githooks/lint.sh b/bin/githooks/lint.sh
new file mode 100755
index 0000000..c6dd63d
--- /dev/null
+++ b/bin/githooks/lint.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+golint ./...
diff --git a/bin/githooks/test.sh b/bin/githooks/test.sh
old mode 100644
new mode 100755
eddd7b12340b9c01a88d86eec5eb71bd641ffb26 Adds split tests
diff --git a/Makefile b/Makefile
index 840cd55..c438ccd 100644
--- a/Makefile
+++ b/Makefile
@@ -6,6 +6,12 @@ RULES_DIR = test/fixtures/rules
 RULES_URL = https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json
 
 
+lint:
+	@golint ./...
+	@go vet ./...
+	@interfacer $(go list ./... | grep -v /vendor/)
+
+
 rules:
 	@curl -s $(RULES_URL) > $(RULES_DIR)/gitrob.json
 
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
index d378a2d..906ef69 100644
--- a/cmd/diffence/main.go
+++ b/cmd/diffence/main.go
@@ -7,6 +7,8 @@ import (
 )
 
 func main() {
-	d := df.NewDiffer()
-	d.Parse(bytes.NewReader([]byte("hello world")))
+	r := bytes.NewReader([]byte("hello world"))
+	items, err := df.SplitDiffs(r)
+	println("items", items)
+	println("err", err)
 }
diff --git a/lib/diff.go b/lib/diff.go
index f07d56c..3a042d6 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -1,59 +1,30 @@
 package diffence
 
-import (
-	"bufio"
-	"bytes"
-	"io"
-)
+import "strings"
 
 // DiffItem is a diff struct for an inidividual file
 type DiffItem struct {
-	raw       []byte
-	filename  []byte
-	addedText []byte
+	raw string
+	// filename  string
+	// addedText string
 	// match        bool
 	// matchedRules []rule
 }
 
-// NewDiffItem is a DiffItem factory
-func NewDiffItem(raw []byte) DiffItem {
-	return DiffItem{
-		raw:       raw,
-		filename:  extractFileName(raw),
-		addedText: extractAddedText(raw),
-	}
+// func (d *DiffItem) getHeader() []byte {
+func (d *DiffItem) getHeader() string {
+	newLineIndex := strings.Index(d.raw, "\n")
+	return d.raw[:newLineIndex]
 }
 
-// Differ creates DiffItems from a raw git diff text input
-type Differ interface {
-	Parse(io.Reader) error
-}
-
-// NewDiffer is a Differ factory
-func NewDiffer() Differ {
-	return &diff{}
-}
-
-type diff struct {
-	items []DiffItem
-}
-
-// Parse splits a diff into individual file diffs and parses each one
-// in a separate go routine
-func (d *diff) Parse(r io.Reader) error {
-
-	scanner := bufio.NewScanner(r)
-	scanner.Split(ScanDiffs)
-
-	// copy to temporary buffer because gets overwritten otherwise
-	// https://golang.org/pkg/bufio/#Scanner.Bytes
-	// "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be OVERWRITTEN by a subsequent call to Scan. It does no allocation."
-	buffer := bytes.NewBuffer(make([]byte, 0))
-
-	for scanner.Scan() {
-		buffer.Write(scanner.Bytes())
-		d.items = append(d.items, NewDiffItem(buffer.Bytes()))
-	}
-
-	return scanner.Err()
-}
+// func (d *DiffItem) getFilename() []byte {
+// 	// prefix := []byte("diff --git a/")
+// 	// firstLine := bytes.SplitN(in, []byte)
+// 	newLineIndex := bytes.IndexByte(d.raw, '\n')
+// 	indexfilePrefix := bytes.LastIndexFunc(
+// 		d.raw[0:newLineIndex],
+// 		unicode.IsSpace,
+// 	)
+// 	prefix := d.raw[indexfilePrefix+1 : newLineIndex]
+// 	return bytes.TrimPrefix(prefix, []byte("b/"))
+// }
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 88ddfe0..6b0afbd 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -1,124 +1,53 @@
 package diffence
 
 import (
-	"bytes"
-	"io"
-	"log"
-	"os"
-	"path"
 	"reflect"
 	"testing"
 )
 
-func TestNewDiffer(t *testing.T) {
-	tests := []struct {
-		name string
-		want Differ
-	}{
-		{
-			name: "NewDiffer factory test",
-			want: &diff{},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			if got := NewDiffer(); !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("NewDiffer() = %v, want %v", got, tt.want)
-			}
-		})
-	}
-}
-
-func getFixtureFile(filename string) io.Reader {
-	cwd, _ := os.Getwd()
-	file, err := os.Open(path.Join(cwd, "../", filename))
-	if err != nil {
-		log.Fatal(err)
-	}
-	return file
-}
-
-func Test_diff_Parse(t *testing.T) {
+func Test_extractFileName(t *testing.T) {
 	type args struct {
-		r io.Reader
+		in string
+	}
+	type want struct {
+		header   string
+		filename string
 	}
 	tests := []struct {
 		name string
 		args args
-		want []DiffItem
+		want want
 	}{
 		{
-			name: "Differ.Parse()",
+			name: "diff.getHeader()",
 			args: args{
-				r: getFixtureFile("test/fixtures/diffs/single.diff"),
+				in: "diff --git a/README.md b/README.md" +
+					"\n" +
+					"index 82366e3..5fc99b9 100644",
 			},
-			want: []DiffItem{
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("README.md"),
-				},
+			want: want{
+				header:   "diff --git a/README.md b/README.md",
+				filename: "README.md",
 			},
 		},
 		{
-			name: "Differ.Parse()",
+			name: "diff.getHeader()",
 			args: args{
-				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
+				in: "diff --git a/TODO.md b/TODO.md" +
+					"\n" +
+					"index 82366e3..5fc99b9 100644",
 			},
-			want: []DiffItem{
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("TODO.md"),
-				},
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("systemdlogger/aws.py"),
-				},
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("systemdlogger/cloudwatch.py"),
-				},
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("tests/fixtures/config.json"),
-				},
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("tests/test_aws.py"),
-				},
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("tests/test_cloudwatch.py"),
-				},
-				DiffItem{
-					raw:      []byte{},
-					filename: []byte("tests/test_runner_integration.py"),
-				},
+			want: want{
+				header:   "diff --git a/TODO.md b/TODO.md",
+				filename: "TODO.md",
 			},
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-
-			d := diff{}
-			if err := d.Parse(tt.args.r); err != nil {
-				t.Fatalf("diff.Parse() throw error %#v", err)
-
-			}
-
-			// check separating items correctly
-			for _, di := range d.items {
-				prefix := []byte("diff --git a")
-				if !bytes.HasPrefix(di.raw, prefix) {
-					t.Fatalf("diff.Parse() not separating items correctly \n\nGOT: %s, \n\nWANT to start with: %s", di.raw, prefix)
-				}
-			}
-			if len(d.items) != len(tt.want) {
-				t.Errorf("diff.Parse() \n\nGOT: %d items, \n\nWANT: %d items", len(d.items), len(tt.want))
-			}
-
-			// check lexing is correct
-			if !reflect.DeepEqual(d.items[0].filename, tt.want[0].filename) {
-				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", d.items[0].filename, tt.want[0].filename)
+			d := DiffItem{tt.args.in}
+			if got := d.getHeader(); !reflect.DeepEqual(got, tt.want.header) {
+				t.Errorf("d.getHeader()\nGOT:%s\nWANT:%s", got, tt.want.header)
 			}
 		})
 	}
diff --git a/lib/extract.go b/lib/extract.go
deleted file mode 100644
index 925b1f3..0000000
--- a/lib/extract.go
+++ /dev/null
@@ -1,18 +0,0 @@
-package diffence
-
-import (
-	"bytes"
-	"unicode"
-)
-
-func extractFileName(in []byte) []byte {
-	// prefix := []byte("diff --git a/")
-	// firstLine := bytes.SplitN(in, []byte)
-	newLineIndex := bytes.IndexByte(in, '\n')
-	fileNameWithPrefixIndex := bytes.LastIndexFunc(in[0:newLineIndex], unicode.IsSpace) + 1
-	return bytes.TrimPrefix(in[fileNameWithPrefixIndex:newLineIndex], []byte("b/"))
-}
-
-func extractAddedText(in []byte) []byte {
-	return []byte("")
-}
diff --git a/lib/extract_test.go b/lib/extract_test.go
deleted file mode 100644
index c5c4908..0000000
--- a/lib/extract_test.go
+++ /dev/null
@@ -1,69 +0,0 @@
-package diffence
-
-import (
-	"reflect"
-	"testing"
-)
-
-func Test_extractFileName(t *testing.T) {
-	type args struct {
-		in []byte
-	}
-	tests := []struct {
-		name string
-		args args
-		want []byte
-	}{
-		{
-
-			name: "ExtractFileName()",
-			args: args{
-				in: []byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			},
-			want: []byte("README.md"),
-		},
-		{
-
-			name: "ExtractFileName()",
-			args: args{
-				in: []byte(
-					"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			},
-			want: []byte("TODO.md"),
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			if got := extractFileName(tt.args.in); !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("extractFileName()\nGOT:%s\nWANT:%s", got, tt.want)
-			}
-		})
-	}
-}
-
-func Test_extractAddedText(t *testing.T) {
-	type args struct {
-		in []byte
-	}
-	tests := []struct {
-		name string
-		args args
-		want []byte
-	}{
-	// TODO: Add test cases.
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			if got := extractAddedText(tt.args.in); !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("extractAddedText() = %v, want %v", got, tt.want)
-			}
-		})
-	}
-}
diff --git a/lib/rules.go b/lib/rules.go
index 8d9c5d8..9aadb93 100644
--- a/lib/rules.go
+++ b/lib/rules.go
@@ -5,11 +5,6 @@ import (
 	"os"
 )
 
-type ruleRunner interface {
-	readRules(jsonFilePath string) (*[]rule, error)
-	runRules(inputText string) []diff
-}
-
 func readRulesFromFile(filePath string) (*[]rule, error) {
 	rules := &[]rule{}
 
diff --git a/lib/scan.go b/lib/scan.go
deleted file mode 100644
index 03962f9..0000000
--- a/lib/scan.go
+++ /dev/null
@@ -1,40 +0,0 @@
-package diffence
-
-import "bytes"
-
-// dropCR drops a terminal \r from the data.
-func dropCR(data []byte) []byte {
-	if len(data) > 0 && data[len(data)-1] == '\r' {
-		return data[0 : len(data)-1]
-	}
-	return data
-}
-
-// ScanDiffs splits on the diff of an inidividual file
-func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
-	if atEOF && len(data) == 0 {
-		return 0, nil, nil
-	}
-
-	k, nextFileDiffIndex, dataLen := 0, 0, len(data)-1
-	for k < dataLen {
-		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
-			// how far advanced already (k)
-			// index after last \n char (+ i)
-			// start at next byte (+ 1)
-			nextFileDiffIndex = k + i + 1
-			if nextFileDiffIndex < dataLen && string(data[nextFileDiffIndex]) == "d" {
-				return nextFileDiffIndex, dropCR(data[0 : k+i]), nil
-			}
-			k += i + 1
-		} else {
-			k = dataLen
-		}
-	}
-	// If we're at EOF, we have a final, non-terminated line. Return it.
-	if atEOF {
-		return len(data), dropCR(data), nil
-	}
-	// Request more data.
-	return 0, nil, nil
-}
diff --git a/lib/scan_test.go b/lib/scan_test.go
deleted file mode 100644
index ea600df..0000000
--- a/lib/scan_test.go
+++ /dev/null
@@ -1,60 +0,0 @@
-package diffence
-
-import (
-	"bufio"
-	"bytes"
-	"io"
-	"reflect"
-	"testing"
-)
-
-func TestScanDiffsWithBufioScanner(t *testing.T) {
-	type args struct {
-		r io.Reader
-	}
-	tests := []struct {
-		name string
-		args args
-		want [][]byte
-	}{
-		{
-			name: "ScanDiffs() split fn",
-			args: args{r: bytes.NewReader(
-				[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644" +
-						"\n" +
-						"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			)},
-			want: [][]byte{
-				[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-				[]byte(
-					"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got := [][]byte{}
-			scanner := bufio.NewScanner(tt.args.r)
-			scanner.Split(ScanDiffs)
-			for scanner.Scan() {
-				got = append(got, scanner.Bytes())
-			}
-			if !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
-			}
-		})
-	}
-}
diff --git a/lib/split.go b/lib/split.go
new file mode 100644
index 0000000..287d14f
--- /dev/null
+++ b/lib/split.go
@@ -0,0 +1,66 @@
+package diffence
+
+import (
+	"bufio"
+	"bytes"
+	"io"
+)
+
+// SplitDiffs splits a single diff txt into an individual DiffItem for each
+// file changed
+func SplitDiffs(r io.Reader) ([]DiffItem, error) {
+
+	scanner := bufio.NewScanner(r)
+	scanner.Split(ScanDiffs)
+
+	// copy to temporary buffer because gets overwritten otherwise
+	// https://golang.org/pkg/bufio/#Scanner.Bytes
+	// "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be OVERWRITTEN by a subsequent call to Scan. It does no allocation."
+	buffer := bytes.NewBuffer(make([]byte, 0))
+	items := []DiffItem{}
+
+	for scanner.Scan() {
+		buffer.Write(scanner.Bytes())
+		items = append(items, DiffItem{buffer.String()})
+		buffer.Reset()
+	}
+
+	return items, scanner.Err()
+}
+
+// ScanDiffs splits on the diff of an inidividual file
+func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
+	if atEOF && len(data) == 0 {
+		return 0, nil, nil
+	}
+
+	k, nextFileDiffIndex, dataLen := 0, 0, len(data)-1
+	for k < dataLen {
+		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
+			// how far advanced already (k)
+			// index after last \n char (+ i)
+			// start at next byte (+ 1)
+			nextFileDiffIndex = k + i + 1
+			if nextFileDiffIndex < dataLen && string(data[nextFileDiffIndex]) == "d" {
+				return nextFileDiffIndex, dropCR(data[0 : k+i]), nil
+			}
+			k += i + 1
+		} else {
+			k = dataLen
+		}
+	}
+	// If we're at EOF, we have a final, non-terminated line. Return it.
+	if atEOF {
+		return len(data), dropCR(data), nil
+	}
+	// Request more data.
+	return 0, nil, nil
+}
+
+// dropCR drops a terminal \r from the data.
+func dropCR(data []byte) []byte {
+	if len(data) > 0 && data[len(data)-1] == '\r' {
+		return data[0 : len(data)-1]
+	}
+	return data
+}
diff --git a/lib/split_test.go b/lib/split_test.go
new file mode 100644
index 0000000..7ede384
--- /dev/null
+++ b/lib/split_test.go
@@ -0,0 +1,154 @@
+package diffence
+
+import (
+	"bufio"
+	"bytes"
+	"io"
+	"log"
+	"os"
+	"path"
+	"reflect"
+	"testing"
+)
+
+func TestScanDiffsWithBufioScanner(t *testing.T) {
+	type args struct {
+		r io.Reader
+	}
+	tests := []struct {
+		name string
+		args args
+		want [][]byte
+	}{
+		{
+			name: "ScanDiffs() split fn",
+			args: args{r: bytes.NewReader(
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644" +
+						"\n" +
+						"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			)},
+			want: [][]byte{
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+				[]byte(
+					"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := [][]byte{}
+			scanner := bufio.NewScanner(tt.args.r)
+			scanner.Split(ScanDiffs)
+			for scanner.Scan() {
+				got = append(got, scanner.Bytes())
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
+			}
+		})
+	}
+}
+
+func getFixtureFile(filename string) io.Reader {
+	cwd, _ := os.Getwd()
+	file, err := os.Open(path.Join(cwd, "../", filename))
+	if err != nil {
+		log.Fatal(err)
+	}
+	return file
+}
+
+func Test_diff_Parse(t *testing.T) {
+	type args struct {
+		r io.Reader
+	}
+	type want struct {
+		header   string
+		filename []byte
+	}
+	tests := []struct {
+		name string
+		args args
+		want []want
+	}{
+		{
+			name: "Differ.Parse()",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/single.diff"),
+			},
+			want: []want{
+				want{
+					header:   "diff --git a/README.md b/README.md",
+					filename: []byte("README.md"),
+				},
+			},
+		},
+		{
+			name: "Differ.Parse()",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
+			},
+			want: []want{
+				want{
+					header:   "diff --git a/TODO.md b/TODO.md",
+					filename: []byte("TODO.md"),
+				},
+				want{
+					header:   "diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py",
+					filename: []byte("systemdlogger/aws.py"),
+				},
+				want{
+					header:   "diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py",
+					filename: []byte("systemdlogger/cloudwatch.py"),
+				},
+				want{
+					header:   "diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json",
+					filename: []byte("tests/fixtures/config.json"),
+				},
+				want{
+					header:   "diff --git a/tests/test_aws.py b/tests/test_aws.py",
+					filename: []byte("tests/test_aws.py"),
+				},
+				want{
+					header:   "diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py",
+					filename: []byte("tests/test_cloudwatch.py"),
+				},
+				want{
+					header:   "diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py",
+					filename: []byte("tests/test_runner_integration.py"),
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+
+			// check for error scanning
+			items, err := SplitDiffs(tt.args.r)
+			if err != nil {
+				t.Fatalf("SplitDiffs threw error %#v", err)
+			}
+
+			// check extracting metadata
+			for i, di := range items {
+				if tt.want[i].header != di.getHeader() {
+					t.Errorf("SplitDiffs() item:%d \nWANT: %s\nGOT: %s", i, tt.want[i].header, di.getHeader())
+					t.Fatalf("Body:\n\n%s", di.raw)
+				}
+			}
+		})
+	}
+}
15caa5b060ba01694b0cd511fcae1d557e3ae38f Fixes main
diff --git a/.gitignore b/.gitignore
index eb23833..fb88369 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,4 @@
-diffence
+./diffence
 releases
 
 # Compiled Object files, Static and Dynamic libs (Shared Objects)
diff --git a/cmd/diffence/main.go b/cmd/diffence/main.go
new file mode 100644
index 0000000..d378a2d
--- /dev/null
+++ b/cmd/diffence/main.go
@@ -0,0 +1,12 @@
+package main
+
+import (
+	"bytes"
+
+	df "github.com/techjacker/diffence/lib"
+)
+
+func main() {
+	d := df.NewDiffer()
+	d.Parse(bytes.NewReader([]byte("hello world")))
+}
diff --git a/diffence b/diffence
new file mode 100755
index 0000000..b5f323f
Binary files /dev/null and b/diffence differ
92f1e5d939f3aaec033f767bef6114995f7fd857 Differ returns error instead of logging it
diff --git a/lib/diff.go b/lib/diff.go
index f78bd84..f07d56c 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -3,10 +3,7 @@ package diffence
 import (
 	"bufio"
 	"bytes"
-	"fmt"
 	"io"
-	"log"
-	"os"
 )
 
 // DiffItem is a diff struct for an inidividual file
@@ -58,10 +55,5 @@ func (d *diff) Parse(r io.Reader) error {
 		d.items = append(d.items, NewDiffItem(buffer.Bytes()))
 	}
 
-	err := scanner.Err()
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "reading input:", err)
-		log.Fatal(err)
-	}
-	return err
+	return scanner.Err()
 }
6ac3f5cc9a144d0d4a0280a4ab2f27efa27bca74 Fixes scanner output being overwritten bug
diff --git a/lib/diff.go b/lib/diff.go
index faf3e82..f78bd84 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -2,7 +2,11 @@ package diffence
 
 import (
 	"bufio"
+	"bytes"
+	"fmt"
 	"io"
+	"log"
+	"os"
 )
 
 // DiffItem is a diff struct for an inidividual file
@@ -25,7 +29,7 @@ func NewDiffItem(raw []byte) DiffItem {
 
 // Differ creates DiffItems from a raw git diff text input
 type Differ interface {
-	Parse(io.Reader)
+	Parse(io.Reader) error
 }
 
 // NewDiffer is a Differ factory
@@ -39,13 +43,25 @@ type diff struct {
 
 // Parse splits a diff into individual file diffs and parses each one
 // in a separate go routine
-func (d *diff) Parse(r io.Reader) {
+func (d *diff) Parse(r io.Reader) error {
 
 	scanner := bufio.NewScanner(r)
 	scanner.Split(ScanDiffs)
 
+	// copy to temporary buffer because gets overwritten otherwise
+	// https://golang.org/pkg/bufio/#Scanner.Bytes
+	// "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be OVERWRITTEN by a subsequent call to Scan. It does no allocation."
+	buffer := bytes.NewBuffer(make([]byte, 0))
+
 	for scanner.Scan() {
-		word := scanner.Bytes()
-		d.items = append(d.items, NewDiffItem(word))
+		buffer.Write(scanner.Bytes())
+		d.items = append(d.items, NewDiffItem(buffer.Bytes()))
+	}
+
+	err := scanner.Err()
+	if err != nil {
+		fmt.Fprintln(os.Stderr, "reading input:", err)
+		log.Fatal(err)
 	}
+	return err
 }
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 553b0bc..88ddfe0 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -1,6 +1,7 @@
 package diffence
 
 import (
+	"bytes"
 	"io"
 	"log"
 	"os"
@@ -58,11 +59,64 @@ func Test_diff_Parse(t *testing.T) {
 				},
 			},
 		},
+		{
+			name: "Differ.Parse()",
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/multi.diff"),
+			},
+			want: []DiffItem{
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("TODO.md"),
+				},
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("systemdlogger/aws.py"),
+				},
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("systemdlogger/cloudwatch.py"),
+				},
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("tests/fixtures/config.json"),
+				},
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("tests/test_aws.py"),
+				},
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("tests/test_cloudwatch.py"),
+				},
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("tests/test_runner_integration.py"),
+				},
+			},
+		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
+
 			d := diff{}
-			d.Parse(tt.args.r)
+			if err := d.Parse(tt.args.r); err != nil {
+				t.Fatalf("diff.Parse() throw error %#v", err)
+
+			}
+
+			// check separating items correctly
+			for _, di := range d.items {
+				prefix := []byte("diff --git a")
+				if !bytes.HasPrefix(di.raw, prefix) {
+					t.Fatalf("diff.Parse() not separating items correctly \n\nGOT: %s, \n\nWANT to start with: %s", di.raw, prefix)
+				}
+			}
+			if len(d.items) != len(tt.want) {
+				t.Errorf("diff.Parse() \n\nGOT: %d items, \n\nWANT: %d items", len(d.items), len(tt.want))
+			}
+
+			// check lexing is correct
 			if !reflect.DeepEqual(d.items[0].filename, tt.want[0].filename) {
 				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", d.items[0].filename, tt.want[0].filename)
 			}
diff --git a/lib/extract_test.go b/lib/extract_test.go
index 3a127d6..c5c4908 100644
--- a/lib/extract_test.go
+++ b/lib/extract_test.go
@@ -21,15 +21,23 @@ func Test_extractFileName(t *testing.T) {
 				in: []byte(
 					"diff --git a/README.md b/README.md" +
 						"\n" +
-						"index 82366e3..5fc99b9 100644" +
-						"\n" +
-						"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
 						"index 82366e3..5fc99b9 100644",
 				),
 			},
 			want: []byte("README.md"),
 		},
+		{
+
+			name: "ExtractFileName()",
+			args: args{
+				in: []byte(
+					"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			},
+			want: []byte("TODO.md"),
+		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
6ac666697c0edfa6e0c13810726ec0e6ec31fe41 Fixes scanner undeclared var error
diff --git a/lib/scan.go b/lib/scan.go
index 54d17bd..03962f9 100644
--- a/lib/scan.go
+++ b/lib/scan.go
@@ -16,7 +16,7 @@ func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
 		return 0, nil, nil
 	}
 
-	k, dataLen := 0, len(data)-1
+	k, nextFileDiffIndex, dataLen := 0, 0, len(data)-1
 	for k < dataLen {
 		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
 			// how far advanced already (k)
6113ba24cd09c2edee7a7281702125673c00ddb5 Updates TODO
diff --git a/README.md b/README.md
index cfdefa5..ef4fcf6 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # diffence
 
-Checks a diff for offensive content.
+Checks a git diff for offensive content.
 
 -----------------------------------------------------------
 
diff --git a/TODO.md b/TODO.md
index 4e9a70b..423aa0b 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,10 +1,34 @@
+Convert extract to lexer
+	- make accept io.Reader (not bytes as arg)
+
+Add more tests
+	- extract_test (/lexer_test)
+		- filename
+		- addedText
+	- diff_test
+		- multi diff test expectations
+		- add more diff fixture files
+
+-----------------------------------------------------------
+Make rules struct private
+	- add getter for channels to access
+
+Add concurrency
+	- each NewDiffItem = new go routine
+	- buffer to max 100?
+		- run benchmark tests (add to tests + makefile)
+
+-----------------------------------------------------------
+
+return just error from main function (vs bool, error)
+
+add logger
+
+-----------------------------------------------------------
 add build task -> convert JSON rules into golang struct
 	- make part of dockerfile?
 
 add multiple rules files to be inputed
 	bufio.MultiReader
 
-add concurrency
-	- each NewDiffItem = new go routine
-	- buffer to max 100?
-		- run benchmark tests (add to tests + makefile)
+set up realize - live reload run tests etc
1f1545385640c67ab210aa8dcfdbe12b5076f36f Adds better scan comments
diff --git a/lib/scan.go b/lib/scan.go
index 3834e24..54d17bd 100644
--- a/lib/scan.go
+++ b/lib/scan.go
@@ -19,9 +19,12 @@ func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
 	k, dataLen := 0, len(data)-1
 	for k < dataLen {
 		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
-			if k+i+1 < dataLen && string(data[k+i+1]) == "d" {
-				return k + i + 1, dropCR(data[0 : k+i]), nil
-				// start at index after last \n char
+			// how far advanced already (k)
+			// index after last \n char (+ i)
+			// start at next byte (+ 1)
+			nextFileDiffIndex = k + i + 1
+			if nextFileDiffIndex < dataLen && string(data[nextFileDiffIndex]) == "d" {
+				return nextFileDiffIndex, dropCR(data[0 : k+i]), nil
 			}
 			k += i + 1
 		} else {
aad93bf723cd7155dcf60818c8f3102de9919110 Adds TODO
diff --git a/TODO.md b/TODO.md
new file mode 100644
index 0000000..4e9a70b
--- /dev/null
+++ b/TODO.md
@@ -0,0 +1,10 @@
+add build task -> convert JSON rules into golang struct
+	- make part of dockerfile?
+
+add multiple rules files to be inputed
+	bufio.MultiReader
+
+add concurrency
+	- each NewDiffItem = new go routine
+	- buffer to max 100?
+		- run benchmark tests (add to tests + makefile)
diff --git a/lib/extract_test.go b/lib/extract_test.go
index ddce4f3..3a127d6 100644
--- a/lib/extract_test.go
+++ b/lib/extract_test.go
@@ -39,3 +39,23 @@ func Test_extractFileName(t *testing.T) {
 		})
 	}
 }
+
+func Test_extractAddedText(t *testing.T) {
+	type args struct {
+		in []byte
+	}
+	tests := []struct {
+		name string
+		args args
+		want []byte
+	}{
+	// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := extractAddedText(tt.args.in); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("extractAddedText() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
efbf230b50c372dff2eee6524e886687d75bf76c Adds extract file name tests from diff
diff --git a/lib/diff.go b/lib/diff.go
index 54927a1..faf3e82 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -7,9 +7,9 @@ import (
 
 // DiffItem is a diff struct for an inidividual file
 type DiffItem struct {
-	raw      []byte
-	filename []byte
-	// addedText    []byte
+	raw       []byte
+	filename  []byte
+	addedText []byte
 	// match        bool
 	// matchedRules []rule
 }
@@ -17,8 +17,9 @@ type DiffItem struct {
 // NewDiffItem is a DiffItem factory
 func NewDiffItem(raw []byte) DiffItem {
 	return DiffItem{
-		raw:      raw,
-		filename: []byte("README.md"),
+		raw:       raw,
+		filename:  extractFileName(raw),
+		addedText: extractAddedText(raw),
 	}
 }
 
diff --git a/lib/extract.go b/lib/extract.go
new file mode 100644
index 0000000..925b1f3
--- /dev/null
+++ b/lib/extract.go
@@ -0,0 +1,18 @@
+package diffence
+
+import (
+	"bytes"
+	"unicode"
+)
+
+func extractFileName(in []byte) []byte {
+	// prefix := []byte("diff --git a/")
+	// firstLine := bytes.SplitN(in, []byte)
+	newLineIndex := bytes.IndexByte(in, '\n')
+	fileNameWithPrefixIndex := bytes.LastIndexFunc(in[0:newLineIndex], unicode.IsSpace) + 1
+	return bytes.TrimPrefix(in[fileNameWithPrefixIndex:newLineIndex], []byte("b/"))
+}
+
+func extractAddedText(in []byte) []byte {
+	return []byte("")
+}
diff --git a/lib/extract_test.go b/lib/extract_test.go
new file mode 100644
index 0000000..ddce4f3
--- /dev/null
+++ b/lib/extract_test.go
@@ -0,0 +1,41 @@
+package diffence
+
+import (
+	"reflect"
+	"testing"
+)
+
+func Test_extractFileName(t *testing.T) {
+	type args struct {
+		in []byte
+	}
+	tests := []struct {
+		name string
+		args args
+		want []byte
+	}{
+		{
+
+			name: "ExtractFileName()",
+			args: args{
+				in: []byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644" +
+						"\n" +
+						"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			},
+			want: []byte("README.md"),
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := extractFileName(tt.args.in); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("extractFileName()\nGOT:%s\nWANT:%s", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/lib/scan_test.go b/lib/scan_test.go
index 574d35b..ea600df 100644
--- a/lib/scan_test.go
+++ b/lib/scan_test.go
@@ -8,37 +8,6 @@ import (
 	"testing"
 )
 
-// func TestScanDiffs(t *testing.T) {
-// 	type args struct {
-// 		data  []byte
-// 		atEOF bool
-// 	}
-// 	tests := []struct {
-// 		name        string
-// 		args        args
-// 		wantAdvance int
-// 		wantToken   []byte
-// 		wantErr     bool
-// 	}{
-// 	// TODO: Add test cases.
-// 	}
-// 	for _, tt := range tests {
-// 		t.Run(tt.name, func(t *testing.T) {
-// 			gotAdvance, gotToken, err := ScanDiffs(tt.args.data, tt.args.atEOF)
-// 			if (err != nil) != tt.wantErr {
-// 				t.Errorf("ScanDiffs() error = %v, wantErr %v", err, tt.wantErr)
-// 				return
-// 			}
-// 			if gotAdvance != tt.wantAdvance {
-// 				t.Errorf("ScanDiffs() gotAdvance = %v, want %v", gotAdvance, tt.wantAdvance)
-// 			}
-// 			if !reflect.DeepEqual(gotToken, tt.wantToken) {
-// 				t.Errorf("ScanDiffs() gotToken = %v, want %v", gotToken, tt.wantToken)
-// 			}
-// 		})
-// 	}
-// }
-
 func TestScanDiffsWithBufioScanner(t *testing.T) {
 	type args struct {
 		r io.Reader
@@ -49,7 +18,7 @@ func TestScanDiffsWithBufioScanner(t *testing.T) {
 		want [][]byte
 	}{
 		{
-			name: "Differ.Parse()",
+			name: "ScanDiffs() split fn",
 			args: args{r: bytes.NewReader(
 				[]byte(
 					"diff --git a/README.md b/README.md" +
4f21fb8a4fcd621ab60c05fea27629982babb2a7 Adds magic 8 ball NewDiffItem tests
diff --git a/lib/diff.go b/lib/diff.go
index 21c2ea8..54927a1 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -5,18 +5,26 @@ import (
 	"io"
 )
 
-type diffItem struct {
-	data []byte
-	// filename     []byte
+// DiffItem is a diff struct for an inidividual file
+type DiffItem struct {
+	raw      []byte
+	filename []byte
 	// addedText    []byte
 	// match        bool
 	// matchedRules []rule
 }
 
-// Differ creates diffItems from a raw git diff text input
+// NewDiffItem is a DiffItem factory
+func NewDiffItem(raw []byte) DiffItem {
+	return DiffItem{
+		raw:      raw,
+		filename: []byte("README.md"),
+	}
+}
+
+// Differ creates DiffItems from a raw git diff text input
 type Differ interface {
-	// split(string) []string
-	Parse(io.Reader) []diffItem
+	Parse(io.Reader)
 }
 
 // NewDiffer is a Differ factory
@@ -24,25 +32,19 @@ func NewDiffer() Differ {
 	return &diff{}
 }
 
-type diff struct{}
+type diff struct {
+	items []DiffItem
+}
 
 // Parse splits a diff into individual file diffs and parses each one
 // in a separate go routine
-func (d diff) Parse(r io.Reader) []diffItem {
+func (d *diff) Parse(r io.Reader) {
 
-	// Default scanner is bufio.ScanLines. Lets use ScanWords.
-	// Could also use a custom function of SplitFunc type
 	scanner := bufio.NewScanner(r)
 	scanner.Split(ScanDiffs)
 
-	items := []diffItem{}
-	// i := 0
 	for scanner.Scan() {
 		word := scanner.Bytes()
-		// fmt.Printf("%d: %#s\n", i, pretty.Formatter(word))
-		// i += 1
-		items = append(items, diffItem{word})
+		d.items = append(d.items, NewDiffItem(word))
 	}
-
-	return items
 }
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 5b3a0ca..553b0bc 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -1,10 +1,10 @@
 package diffence
 
 import (
-	"bytes"
 	"io"
 	"log"
 	"os"
+	"path"
 	"reflect"
 	"testing"
 )
@@ -28,6 +28,15 @@ func TestNewDiffer(t *testing.T) {
 	}
 }
 
+func getFixtureFile(filename string) io.Reader {
+	cwd, _ := os.Getwd()
+	file, err := os.Open(path.Join(cwd, "../", filename))
+	if err != nil {
+		log.Fatal(err)
+	}
+	return file
+}
+
 func Test_diff_Parse(t *testing.T) {
 	type args struct {
 		r io.Reader
@@ -35,50 +44,28 @@ func Test_diff_Parse(t *testing.T) {
 	tests := []struct {
 		name string
 		args args
-		want []diffItem
+		want []DiffItem
 	}{
 		{
 			name: "Differ.Parse()",
-			// args: args{r: getFixtureFile("test/fixtures/diffs/single.diff")},
-			args: args{r: bytes.NewReader(
-				[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644" +
-						"\n" +
-						"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				),
-			)},
-			want: []diffItem{
-				diffItem{[]byte(
-					"diff --git a/README.md b/README.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				)},
-				diffItem{[]byte(
-					"diff --git a/TODO.md b/TODO.md" +
-						"\n" +
-						"index 82366e3..5fc99b9 100644",
-				)},
+			args: args{
+				r: getFixtureFile("test/fixtures/diffs/single.diff"),
+			},
+			want: []DiffItem{
+				DiffItem{
+					raw:      []byte{},
+					filename: []byte("README.md"),
+				},
 			},
 		},
 	}
-	for i, tt := range tests {
+	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			d := diff{}
-			if got := d.Parse(tt.args.r); !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
+			d.Parse(tt.args.r)
+			if !reflect.DeepEqual(d.items[0].filename, tt.want[0].filename) {
+				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", d.items[0].filename, tt.want[0].filename)
 			}
 		})
 	}
 }
-
-func getFixtureFile(filename string) io.Reader {
-	file, err := os.Open(filename)
-	if err != nil {
-		log.Fatal(err)
-	}
-	return file
-}
diff --git a/lib/scan.go b/lib/scan.go
index 6c52c85..3834e24 100644
--- a/lib/scan.go
+++ b/lib/scan.go
@@ -19,7 +19,7 @@ func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
 	k, dataLen := 0, len(data)-1
 	for k < dataLen {
 		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
-			if string(data[k+i+1]) == "d" {
+			if k+i+1 < dataLen && string(data[k+i+1]) == "d" {
 				return k + i + 1, dropCR(data[0 : k+i]), nil
 				// start at index after last \n char
 			}
diff --git a/lib/scan_test.go b/lib/scan_test.go
new file mode 100644
index 0000000..574d35b
--- /dev/null
+++ b/lib/scan_test.go
@@ -0,0 +1,91 @@
+package diffence
+
+import (
+	"bufio"
+	"bytes"
+	"io"
+	"reflect"
+	"testing"
+)
+
+// func TestScanDiffs(t *testing.T) {
+// 	type args struct {
+// 		data  []byte
+// 		atEOF bool
+// 	}
+// 	tests := []struct {
+// 		name        string
+// 		args        args
+// 		wantAdvance int
+// 		wantToken   []byte
+// 		wantErr     bool
+// 	}{
+// 	// TODO: Add test cases.
+// 	}
+// 	for _, tt := range tests {
+// 		t.Run(tt.name, func(t *testing.T) {
+// 			gotAdvance, gotToken, err := ScanDiffs(tt.args.data, tt.args.atEOF)
+// 			if (err != nil) != tt.wantErr {
+// 				t.Errorf("ScanDiffs() error = %v, wantErr %v", err, tt.wantErr)
+// 				return
+// 			}
+// 			if gotAdvance != tt.wantAdvance {
+// 				t.Errorf("ScanDiffs() gotAdvance = %v, want %v", gotAdvance, tt.wantAdvance)
+// 			}
+// 			if !reflect.DeepEqual(gotToken, tt.wantToken) {
+// 				t.Errorf("ScanDiffs() gotToken = %v, want %v", gotToken, tt.wantToken)
+// 			}
+// 		})
+// 	}
+// }
+
+func TestScanDiffsWithBufioScanner(t *testing.T) {
+	type args struct {
+		r io.Reader
+	}
+	tests := []struct {
+		name string
+		args args
+		want [][]byte
+	}{
+		{
+			name: "Differ.Parse()",
+			args: args{r: bytes.NewReader(
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644" +
+						"\n" +
+						"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			)},
+			want: [][]byte{
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+				[]byte(
+					"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := [][]byte{}
+			scanner := bufio.NewScanner(tt.args.r)
+			scanner.Split(ScanDiffs)
+			for scanner.Scan() {
+				got = append(got, scanner.Bytes())
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
+			}
+		})
+	}
+}
87b383e9c4e236ecb84f23bcb670c3a0f2e46deb Adds ScanDiffs scanner
diff --git a/Makefile b/Makefile
index c01831c..840cd55 100644
--- a/Makefile
+++ b/Makefile
@@ -17,7 +17,7 @@ run:
 	@go build ./cmd/diffence && ./diffence
 
 test:
-	@go test -v ./...
+	@go test ./...
 
 test-race:
 	@go test -race ./...
diff --git a/lib/diff.go b/lib/diff.go
index 53d5161..21c2ea8 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -6,11 +6,11 @@ import (
 )
 
 type diffItem struct {
-	data         []byte
-	filename     []byte
-	addedText    []byte
-	match        bool
-	matchedRules []rule
+	data []byte
+	// filename     []byte
+	// addedText    []byte
+	// match        bool
+	// matchedRules []rule
 }
 
 // Differ creates diffItems from a raw git diff text input
@@ -26,17 +26,21 @@ func NewDiffer() Differ {
 
 type diff struct{}
 
+// Parse splits a diff into individual file diffs and parses each one
+// in a separate go routine
 func (d diff) Parse(r io.Reader) []diffItem {
 
-	items := []diffItem{}
-
 	// Default scanner is bufio.ScanLines. Lets use ScanWords.
 	// Could also use a custom function of SplitFunc type
 	scanner := bufio.NewScanner(r)
-	scanner.Split(bufio.ScanWords)
+	scanner.Split(ScanDiffs)
 
+	items := []diffItem{}
+	// i := 0
 	for scanner.Scan() {
 		word := scanner.Bytes()
+		// fmt.Printf("%d: %#s\n", i, pretty.Formatter(word))
+		// i += 1
 		items = append(items, diffItem{word})
 	}
 
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 34765ec..5b3a0ca 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -40,18 +40,36 @@ func Test_diff_Parse(t *testing.T) {
 		{
 			name: "Differ.Parse()",
 			// args: args{r: getFixtureFile("test/fixtures/diffs/single.diff")},
-			args: args{r: bytes.NewReader([]byte("random text"))},
+			args: args{r: bytes.NewReader(
+				[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644" +
+						"\n" +
+						"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				),
+			)},
 			want: []diffItem{
-				diffItem{[]byte("random")},
-				diffItem{[]byte("text")},
+				diffItem{[]byte(
+					"diff --git a/README.md b/README.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				)},
+				diffItem{[]byte(
+					"diff --git a/TODO.md b/TODO.md" +
+						"\n" +
+						"index 82366e3..5fc99b9 100644",
+				)},
 			},
 		},
 	}
-	for _, tt := range tests {
+	for i, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			d := diff{}
 			if got := d.Parse(tt.args.r); !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("diff.Parse() = %v, want %v", got, tt.want)
+				t.Errorf("diff.Parse() \n\nGOT: %s, \n\nWANT: %s", got, tt.want)
 			}
 		})
 	}
diff --git a/lib/scan.go b/lib/scan.go
new file mode 100644
index 0000000..6c52c85
--- /dev/null
+++ b/lib/scan.go
@@ -0,0 +1,37 @@
+package diffence
+
+import "bytes"
+
+// dropCR drops a terminal \r from the data.
+func dropCR(data []byte) []byte {
+	if len(data) > 0 && data[len(data)-1] == '\r' {
+		return data[0 : len(data)-1]
+	}
+	return data
+}
+
+// ScanDiffs splits on the diff of an inidividual file
+func ScanDiffs(data []byte, atEOF bool) (advance int, token []byte, err error) {
+	if atEOF && len(data) == 0 {
+		return 0, nil, nil
+	}
+
+	k, dataLen := 0, len(data)-1
+	for k < dataLen {
+		if i := bytes.IndexByte(data[k:], '\n'); i >= 0 {
+			if string(data[k+i+1]) == "d" {
+				return k + i + 1, dropCR(data[0 : k+i]), nil
+				// start at index after last \n char
+			}
+			k += i + 1
+		} else {
+			k = dataLen
+		}
+	}
+	// If we're at EOF, we have a final, non-terminated line. Return it.
+	if atEOF {
+		return len(data), dropCR(data), nil
+	}
+	// Request more data.
+	return 0, nil, nil
+}
64ff49505e9556de4122e5f2ef201e225f5eb5c4 Stubs diffItem implementation
diff --git a/lib/diff.go b/lib/diff.go
index bac5aa7..53d5161 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -1,37 +1,44 @@
 package diffence
 
+import (
+	"bufio"
+	"io"
+)
+
 type diffItem struct {
-	rawText      string
-	filename     string
-	addedText    string
+	data         []byte
+	filename     []byte
+	addedText    []byte
 	match        bool
 	matchedRules []rule
 }
 
 // Differ creates diffItems from a raw git diff text input
 type Differ interface {
-	split(string) []string
-	parse([]string) []diffItem
-	Run() error
+	// split(string) []string
+	Parse(io.Reader) []diffItem
 }
 
 // NewDiffer is a Differ factory
-func NewDiffer(in string) Differ {
-	return &diff{rawText: in}
+func NewDiffer() Differ {
+	return &diff{}
 }
 
-type diff struct {
-	rawText string
-}
+type diff struct{}
 
-func (d diff) split(s string) []string {
-	return []string{}
-}
+func (d diff) Parse(r io.Reader) []diffItem {
 
-func (d diff) parse(sArr []string) []diffItem {
-	return []diffItem{}
-}
+	items := []diffItem{}
+
+	// Default scanner is bufio.ScanLines. Lets use ScanWords.
+	// Could also use a custom function of SplitFunc type
+	scanner := bufio.NewScanner(r)
+	scanner.Split(bufio.ScanWords)
+
+	for scanner.Scan() {
+		word := scanner.Bytes()
+		items = append(items, diffItem{word})
+	}
 
-func (d diff) Run() error {
-	return nil
+	return items
 }
diff --git a/lib/diff_test.go b/lib/diff_test.go
index 74e2ebd..34765ec 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -1,30 +1,66 @@
 package diffence
 
 import (
+	"bytes"
+	"io"
+	"log"
+	"os"
 	"reflect"
 	"testing"
 )
 
 func TestNewDiffer(t *testing.T) {
+	tests := []struct {
+		name string
+		want Differ
+	}{
+		{
+			name: "NewDiffer factory test",
+			want: &diff{},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := NewDiffer(); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("NewDiffer() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func Test_diff_Parse(t *testing.T) {
 	type args struct {
-		in string
+		r io.Reader
 	}
 	tests := []struct {
 		name string
 		args args
-		want *diff
+		want []diffItem
 	}{
 		{
-			name: "no op test",
-			args: args{in: "test diff"},
-			want: &diff{rawText: "test diff"},
+			name: "Differ.Parse()",
+			// args: args{r: getFixtureFile("test/fixtures/diffs/single.diff")},
+			args: args{r: bytes.NewReader([]byte("random text"))},
+			want: []diffItem{
+				diffItem{[]byte("random")},
+				diffItem{[]byte("text")},
+			},
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			if got := NewDiffer(tt.args.in); !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("NewDiffer() = %v, want %v", got, tt.want)
+			d := diff{}
+			if got := d.Parse(tt.args.r); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("diff.Parse() = %v, want %v", got, tt.want)
 			}
 		})
 	}
 }
+
+func getFixtureFile(filename string) io.Reader {
+	file, err := os.Open(filename)
+	if err != nil {
+		log.Fatal(err)
+	}
+	return file
+}
diff --git a/test/fixtures/diffs/single.diff b/test/fixtures/diffs/single.diff
new file mode 100644
index 0000000..07f8683
--- /dev/null
+++ b/test/fixtures/diffs/single.diff
@@ -0,0 +1,13 @@
+diff --git a/README.md b/README.md
+index 82366e3..5fc99b9 100644
+--- a/README.md
++++ b/README.md
+@@ -1,7 +1,8 @@
+ # systemdlogger
+
+-- Exports systemd logs to an external service, eg cloudwatch, elasticsearch.
+-- Use with a cron job.
++- Lightweight, python only, logstash alternative
++- Exports systemd journald logs to an external service, eg cloudwatch, elasticsearch
++- Use with a cron job
+ - Python 3+
diff --git a/test/fixtures/single.diff b/test/fixtures/single.diff
deleted file mode 100644
index 07f8683..0000000
--- a/test/fixtures/single.diff
+++ /dev/null
@@ -1,13 +0,0 @@
-diff --git a/README.md b/README.md
-index 82366e3..5fc99b9 100644
---- a/README.md
-+++ b/README.md
-@@ -1,7 +1,8 @@
- # systemdlogger
-
--- Exports systemd logs to an external service, eg cloudwatch, elasticsearch.
--- Use with a cron job.
-+- Lightweight, python only, logstash alternative
-+- Exports systemd journald logs to an external service, eg cloudwatch, elasticsearch
-+- Use with a cron job
- - Python 3+
0818cbb8a33b89a6304519e3e8e4fc982993f191 Removes hello world
diff --git a/lib/diff.go b/lib/diff.go
index a062a22..bac5aa7 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -12,6 +12,7 @@ type diffItem struct {
 type Differ interface {
 	split(string) []string
 	parse([]string) []diffItem
+	Run() error
 }
 
 // NewDiffer is a Differ factory
@@ -30,3 +31,7 @@ func (d diff) split(s string) []string {
 func (d diff) parse(sArr []string) []diffItem {
 	return []diffItem{}
 }
+
+func (d diff) Run() error {
+	return nil
+}
diff --git a/lib/diff_test.go b/lib/diff_test.go
index db5e291..74e2ebd 100644
--- a/lib/diff_test.go
+++ b/lib/diff_test.go
@@ -14,7 +14,11 @@ func TestNewDiffer(t *testing.T) {
 		args args
 		want *diff
 	}{
-	// TODO: Add test cases.
+		{
+			name: "no op test",
+			args: args{in: "test diff"},
+			want: &diff{rawText: "test diff"},
+		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
diff --git a/lib/hello.go b/lib/hello.go
deleted file mode 100644
index c24409b..0000000
--- a/lib/hello.go
+++ /dev/null
@@ -1,12 +0,0 @@
-package diffence
-
-import "fmt"
-
-// Hello says whatever you asks it to say
-func Hello(msg string) {
-	fmt.Println(noop(msg))
-}
-
-func noop(msg string) string {
-	return msg
-}
diff --git a/lib/hello_test.go b/lib/hello_test.go
deleted file mode 100644
index 4a1a52d..0000000
--- a/lib/hello_test.go
+++ /dev/null
@@ -1,27 +0,0 @@
-package diffence
-
-import "testing"
-
-func Test_noop(t *testing.T) {
-	type args struct {
-		msg string
-	}
-	tests := []struct {
-		name string
-		args args
-		want string
-	}{
-		{
-			name: "no op test",
-			args: args{msg: "test message"},
-			want: "test message",
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			if got := noop(tt.args.msg); got != tt.want {
-				t.Errorf("noop() = %v, want %v", got, tt.want)
-			}
-		})
-	}
-}
b4c5de8057598e414d29efcd15516d3b3e92ceab Stubs differ
diff --git a/lib/diff.go b/lib/diff.go
index c46565f..a062a22 100644
--- a/lib/diff.go
+++ b/lib/diff.go
@@ -1,7 +1,32 @@
 package diffence
 
-type diff struct {
-	text         string
+type diffItem struct {
+	rawText      string
+	filename     string
+	addedText    string
 	match        bool
 	matchedRules []rule
 }
+
+// Differ creates diffItems from a raw git diff text input
+type Differ interface {
+	split(string) []string
+	parse([]string) []diffItem
+}
+
+// NewDiffer is a Differ factory
+func NewDiffer(in string) Differ {
+	return &diff{rawText: in}
+}
+
+type diff struct {
+	rawText string
+}
+
+func (d diff) split(s string) []string {
+	return []string{}
+}
+
+func (d diff) parse(sArr []string) []diffItem {
+	return []diffItem{}
+}
diff --git a/lib/diff_test.go b/lib/diff_test.go
new file mode 100644
index 0000000..db5e291
--- /dev/null
+++ b/lib/diff_test.go
@@ -0,0 +1,26 @@
+package diffence
+
+import (
+	"reflect"
+	"testing"
+)
+
+func TestNewDiffer(t *testing.T) {
+	type args struct {
+		in string
+	}
+	tests := []struct {
+		name string
+		args args
+		want *diff
+	}{
+	// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := NewDiffer(tt.args.in); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("NewDiffer() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
def86797c072240d07bb961bbc9ea93f81cc1429 Adds tests for race conditions
diff --git a/Makefile b/Makefile
index 1e9ca0a..c01831c 100644
--- a/Makefile
+++ b/Makefile
@@ -19,4 +19,8 @@ run:
 test:
 	@go test -v ./...
 
+test-race:
+	@go test -race ./...
+
+
 .PHONY: test run
diff --git a/bin/githooks/test.sh b/bin/githooks/test.sh
index 600912e..e7690a2 100644
--- a/bin/githooks/test.sh
+++ b/bin/githooks/test.sh
@@ -4,3 +4,7 @@
 # go get github.com/ChimeraCoder/gojson/gojson
 ####################
 go test ./...
+
+# check for race conditions
+go test -race ./...
+# go run -race ./cmd/diffence/main.go -config ./test/fixtures/config.json
71104bfc920b477df046e828a4219f4056eb2f89 Adds diff type
diff --git a/Makefile b/Makefile
index 46e1489..1e9ca0a 100644
--- a/Makefile
+++ b/Makefile
@@ -1,17 +1,16 @@
 USER = techjacker
 REPO = systemdlogger
-COMMIT_ID = a4e1c01c137c2218684fd59da54d769623ac567f
+COMMIT_ID = 94c52865e3b449ca594d09995b99efc28a24c53d
 
 RULES_DIR = test/fixtures/rules
 RULES_URL = https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json
 
 
-# https://github.com/michenriksen/gitrob/blob/master/signatures.json
 rules:
 	@curl -s $(RULES_URL) > $(RULES_DIR)/gitrob.json
 
 diff:
-	@curl -L https://api.github.com/repos/$(USER)/$(REPO)/commits/$(COMMIT_ID) \
+	@curl -s https://api.github.com/repos/$(USER)/$(REPO)/commits/$(COMMIT_ID) \
 		-H "Accept: application/vnd.github.VERSION.diff"
 
 run:
diff --git a/lib/diff.go b/lib/diff.go
new file mode 100644
index 0000000..c46565f
--- /dev/null
+++ b/lib/diff.go
@@ -0,0 +1,7 @@
+package diffence
+
+type diff struct {
+	text         string
+	match        bool
+	matchedRules []rule
+}
diff --git a/lib/rules.go b/lib/rules.go
index 9aadb93..8d9c5d8 100644
--- a/lib/rules.go
+++ b/lib/rules.go
@@ -5,6 +5,11 @@ import (
 	"os"
 )
 
+type ruleRunner interface {
+	readRules(jsonFilePath string) (*[]rule, error)
+	runRules(inputText string) []diff
+}
+
 func readRulesFromFile(filePath string) (*[]rule, error) {
 	rules := &[]rule{}
 
diff --git a/test/fixtures/diff.txt b/test/fixtures/diff.txt
deleted file mode 100644
index 07f8683..0000000
--- a/test/fixtures/diff.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-diff --git a/README.md b/README.md
-index 82366e3..5fc99b9 100644
---- a/README.md
-+++ b/README.md
-@@ -1,7 +1,8 @@
- # systemdlogger
-
--- Exports systemd logs to an external service, eg cloudwatch, elasticsearch.
--- Use with a cron job.
-+- Lightweight, python only, logstash alternative
-+- Exports systemd journald logs to an external service, eg cloudwatch, elasticsearch
-+- Use with a cron job
- - Python 3+
diff --git a/test/fixtures/diffs/multi.diff b/test/fixtures/diffs/multi.diff
new file mode 100644
index 0000000..7ed7192
--- /dev/null
+++ b/test/fixtures/diffs/multi.diff
@@ -0,0 +1,223 @@
+diff --git a/TODO.md b/TODO.md
+index 96537ef..a834173 100644
+--- a/TODO.md
++++ b/TODO.md
+@@ -10,12 +10,6 @@ make test-integration
+ -----------------------------------------------------------
+ -----------------------------------------------------------
+ 
+-make aws creds params optional (cloudwatch)
+-	- switch to **kwargs style?
+-
+------------------------------------------------------------
+------------------------------------------------------------
+-
+ bulk save
+ 	combine entries with same timestamp into single doctype
+ 
+diff --git a/systemdlogger/aws.py b/systemdlogger/aws.py
+index ddd9caa..bc93f19 100644
+--- a/systemdlogger/aws.py
++++ b/systemdlogger/aws.py
+@@ -12,16 +12,13 @@ class AWSLogger():
+         '/latest/dynamic/instance-identity/document'
+     )
+ 
+-    def __init__(self, aws_service, access_key, secret_key, region):
++    # def __init__(self, aws_service, access_key, secret_key, region):
++    def __init__(self, aws_service, aws_params={}):
+         if aws_service not in AWSLogger.services:
+             raise Exception('logger must be one of %s' % AWSLogger.services)
+         self.aws_service = aws_service
+         self.metadata = self.load_metadata()
+-        self.client = self.create_client(
+-            access_key=access_key,
+-            secret_key=secret_key,
+-            region=region
+-        )
++        self.client = self.create_client(**aws_params)
+ 
+     def create_client(self, access_key, secret_key, region):
+         if access_key and secret_key and region:
+diff --git a/systemdlogger/cloudwatch.py b/systemdlogger/cloudwatch.py
+index dd088de..0df7283 100755
+--- a/systemdlogger/cloudwatch.py
++++ b/systemdlogger/cloudwatch.py
+@@ -12,16 +12,9 @@ def __init__(
+         seq_tok_filename,
+         log_group_name,
+         log_stream_name,
+-        access_key,
+-        secret_key,
+-        region
++        aws_params={}
+     ):
+-        super().__init__(
+-            'cloudwatch',
+-            access_key,
+-            secret_key,
+-            region
+-        )
++        super().__init__('cloudwatch', aws_params)
+         self.setup_logs(seq_tok_filename, log_group_name, log_stream_name)
+ 
+     def setup_logs(self, seq_tok_filename, log_group_name, log_stream_name):
+diff --git a/tests/fixtures/config.json b/tests/fixtures/config.json
+index 762d14e..5cb4980 100644
+--- a/tests/fixtures/config.json
++++ b/tests/fixtures/config.json
+@@ -7,9 +7,11 @@
+             "log_group_name": "log_group_name",
+             "log_stream_name": "log_stream_name",
+             "seq_tok_filename": "cloudwatch_seq_tok-project-app.txt",
+-            "access_key": "access_key",
+-            "secret_key": "secret_key",
+-            "region": "region"
++            "aws_params": {
++                "access_key": "access_key",
++                "secret_key": "secret_key",
++                "region": "region"
++            }
+         },
+         "es": {
+             "doctype": "webserver",
+diff --git a/tests/test_aws.py b/tests/test_aws.py
+index 888971f..0c7b6fa 100644
+--- a/tests/test_aws.py
++++ b/tests/test_aws.py
+@@ -27,7 +27,7 @@ def metadata():
+ 
+ 
+ @pytest.mark.parametrize(('backend'), allowed_services)
+-class TestInit:
++class TestInitAWS:
+ 
+     def setup_method(self, method):
+         self.AWSLogger = AWSLogger
+@@ -38,12 +38,17 @@ def teardown_method(self, method):
+ 
+     def test_init_load_metadata(self, backend, aws_params):
+         with patch.object(self.AWSLogger, 'create_client') as create_client:
+-            aws = self.AWSLogger(backend, **aws_params)
++            aws = self.AWSLogger(backend, aws_params)
+             assert aws.aws_service == backend
+             create_client.assert_called_once_with(**aws_params)
+             assert self.AWSLogger.load_metadata.call_count == 1
+ 
++    def test_init_without_aws_params(self, backend):
++        with patch.object(self.AWSLogger, 'create_client'):
++            aws = self.AWSLogger(backend)
++            assert aws.aws_service == backend
++
+     def test_init_create_client(self, backend, aws_params, metadata):
+-        logger = self.AWSLogger(backend, **aws_params)
++        logger = self.AWSLogger(backend, aws_params)
+         assert isinstance(
+             logger.client, botocore.client.BaseClient)
+diff --git a/tests/test_cloudwatch.py b/tests/test_cloudwatch.py
+index 5d256c3..f079dd4 100644
+--- a/tests/test_cloudwatch.py
++++ b/tests/test_cloudwatch.py
+@@ -1,38 +1,56 @@
+-from pytest import fixture
+-from unittest.mock import patch
++# from pytest import fixture
++import pytest
++from unittest.mock import Mock
+ from systemdlogger.plugin import PluginBase
+ from systemdlogger.aws import AWSLogger
+ from systemdlogger.cloudwatch import CloudwatchLogger
+ 
+ 
+-@fixture
+-def init_params():
++def params():
+     return {
+         'log_group_name': 'log_group_name',
+         'log_stream_name': 'log_stream_name',
+         'seq_tok_filename': 'seq_tok_filename',
++    }
++
++
++def params_with_aws():
++    p = params()
++    p['aws_params'] = {
+         'access_key': '1234',
+         'secret_key': '567',
+         'region': 'eu-west-1'
+     }
++    return p
++
++
++@pytest.mark.parametrize(('init_params'), [
++    params(),
++    params_with_aws()
++])
++class TestInitCloudwatch:
++    def setup_method(self, method):
++        self.AWSLogger = AWSLogger
++        self.AWSLogger.__init__ = Mock()
++        self.CloudwatchLogger = CloudwatchLogger
++        self.CloudwatchLogger.setup_logs = Mock()
+ 
++    def teardown_method(self, method):
++        self.AWSLogger.__init__.restore()
++        self.CloudwatchLogger.setup_logs.restore()
+ 
+-def test_init(init_params):
+-    with patch.object(AWSLogger, '__init__') as init:
+-        with patch.object(CloudwatchLogger, 'setup_logs') as setup_logs:
+-            cloudwatch_logger = CloudwatchLogger(**init_params)
+-            assert issubclass(CloudwatchLogger, PluginBase)
+-            assert isinstance(cloudwatch_logger, PluginBase)
+-            assert issubclass(CloudwatchLogger, AWSLogger)
+-            assert isinstance(cloudwatch_logger, AWSLogger)
+-            init.assert_called_once_with(
+-                'cloudwatch',
+-                init_params['access_key'],
+-                init_params['secret_key'],
+-                init_params['region']
+-            )
+-            setup_logs.assert_called_once_with(
+-                init_params['seq_tok_filename'],
+-                init_params['log_group_name'],
+-                init_params['log_stream_name']
+-            )
++    def test_init(self, init_params):
++        cloudwatch_logger = CloudwatchLogger(**init_params)
++        assert issubclass(CloudwatchLogger, PluginBase)
++        assert isinstance(cloudwatch_logger, PluginBase)
++        assert issubclass(CloudwatchLogger, AWSLogger)
++        assert isinstance(cloudwatch_logger, AWSLogger)
++        self.AWSLogger.__init__.assert_called_once_with(
++            'cloudwatch',
++            init_params.get('aws_params', {})
++        )
++        self.CloudwatchLogger.setup_logs.assert_called_once_with(
++            init_params['seq_tok_filename'],
++            init_params['log_group_name'],
++            init_params['log_stream_name']
++        )
+diff --git a/tests/test_runner_integration.py b/tests/test_runner_integration.py
+index ee5276b..7c358bc 100644
+--- a/tests/test_runner_integration.py
++++ b/tests/test_runner_integration.py
+@@ -1,14 +1,12 @@
+-from pytest import fixture
++import pytest
+ from unittest.mock import patch
+ import tests.fixtures.journal as FakeJournalExporter
+ from systemdlogger.elasticsearch import ElasticsearchLogger
+ 
+ 
+-@fixture
+-def config_path():
+-    return 'tests/fixtures/config_es.json'
+-
+-
++@pytest.mark.parametrize(('config_path'), [
++    'tests/fixtures/config_es.json'
++])
+ class TestRunner:
+ 
+     def setup_method(self, method):
diff --git a/test/fixtures/single.diff b/test/fixtures/single.diff
new file mode 100644
index 0000000..07f8683
--- /dev/null
+++ b/test/fixtures/single.diff
@@ -0,0 +1,13 @@
+diff --git a/README.md b/README.md
+index 82366e3..5fc99b9 100644
+--- a/README.md
++++ b/README.md
+@@ -1,7 +1,8 @@
+ # systemdlogger
+
+-- Exports systemd logs to an external service, eg cloudwatch, elasticsearch.
+-- Use with a cron job.
++- Lightweight, python only, logstash alternative
++- Exports systemd journald logs to an external service, eg cloudwatch, elasticsearch
++- Use with a cron job
+ - Python 3+
5e9d19418b4d5f558f9fca8202a39ecfe0480bb2 Creates rules subdir in fixtures
diff --git a/Makefile b/Makefile
index 0f426e8..46e1489 100644
--- a/Makefile
+++ b/Makefile
@@ -2,11 +2,13 @@ USER = techjacker
 REPO = systemdlogger
 COMMIT_ID = a4e1c01c137c2218684fd59da54d769623ac567f
 
-GITROB_RULES = https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json
+RULES_DIR = test/fixtures/rules
+RULES_URL = https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json
+
 
 # https://github.com/michenriksen/gitrob/blob/master/signatures.json
 rules:
-	@curl -s $(GITROB_RULES) > ./test/fixtures/gitrob.json
+	@curl -s $(RULES_URL) > $(RULES_DIR)/gitrob.json
 
 diff:
 	@curl -L https://api.github.com/repos/$(USER)/$(REPO)/commits/$(COMMIT_ID) \
diff --git a/bin/githooks/test.sh b/bin/githooks/test.sh
new file mode 100644
index 0000000..600912e
--- /dev/null
+++ b/bin/githooks/test.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+####################
+# go get github.com/ChimeraCoder/gojson/gojson
+####################
+go test ./...
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
index 59ff8c4..ecb1ff2 100644
--- a/lib/rule_tmpl.go
+++ b/lib/rule_tmpl.go
@@ -1,3 +1,3 @@
 package diffence
 
-//go:generate gojson -name rule -input ./../test/fixtures/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
+//go:generate gojson -name rule -input ./../test/fixtures/rules/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
diff --git a/lib/rules_test.go b/lib/rules_test.go
index 5d3d5f6..1154454 100644
--- a/lib/rules_test.go
+++ b/lib/rules_test.go
@@ -17,7 +17,7 @@ func Test_readRules(t *testing.T) {
 	}{
 		{
 			name: "Read rules from file",
-			args: args{filePath: "./../test/fixtures/rules.json"},
+			args: args{filePath: "./../test/fixtures/rules/rules.json"},
 			want: &[]rule{
 				{
 					Part:        "filename",
diff --git a/test/fixtures/gitrob.json b/test/fixtures/gitrob.json
deleted file mode 100644
index a64f2bd..0000000
--- a/test/fixtures/gitrob.json
+++ /dev/null
@@ -1,555 +0,0 @@
-[
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A.*_rsa\\z",
-    "caption": "Private SSH key",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A.*_dsa\\z",
-    "caption": "Private SSH key",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A.*_ed25519\\z",
-    "caption": "Private SSH key",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A.*_ecdsa\\z",
-    "caption": "Private SSH key",
-    "description": null
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?ssh/config\\z",
-    "caption": "SSH configuration file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "pem",
-    "caption": "Potential cryptographic private key",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "regex",
-    "pattern": "\\Akey(pair)?\\z",
-    "caption": "Potential cryptographic private key",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "pkcs12",
-    "caption": "Potential cryptographic key bundle",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "pfx",
-    "caption": "Potential cryptographic key bundle",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "p12",
-    "caption": "Potential cryptographic key bundle",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "asc",
-    "caption": "Potential cryptographic key bundle",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "otr.private_key",
-    "caption": "Pidgin OTR private key",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?(bash_|zsh_|z)?history\\z",
-    "caption": "Shell command history file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?mysql_history\\z",
-    "caption": "MySQL client command history file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?psql_history\\z",
-    "caption": "PostgreSQL client command history file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?pgpass\\z",
-    "caption": "PostgreSQL password file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?irb_history\\z",
-    "caption": "Ruby IRB console history file",
-    "description": null
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?purple\\/accounts\\.xml\\z",
-    "caption": "Pidgin chat client account configuration file",
-    "description": null
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?xchat2?\\/servlist_?\\.conf\\z",
-    "caption": "Hexchat/XChat IRC client server list configuration file",
-    "description": null
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?irssi\\/config\\z",
-    "caption": "Irssi IRC client configuration file",
-    "description": null
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?recon-ng\\/keys\\.db\\z",
-    "caption": "Recon-ng web reconnaissance framework API key database",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?dbeaver-data-sources.xml\\z",
-    "caption": "DBeaver SQL database manager configuration file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?muttrc\\z",
-    "caption": "Mutt e-mail client configuration file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?s3cfg\\z",
-    "caption": "S3cmd configuration file",
-    "description": null
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?aws/credentials\\z",
-    "caption": "AWS CLI credentials file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?trc\\z",
-    "caption": "T command-line Twitter client configuration file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "ovpn",
-    "caption": "OpenVPN client configuration file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?gitrobrc\\z",
-    "caption": "Well, this is awkward... Gitrob configuration file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?(bash|zsh)rc\\z",
-    "caption": "Shell configuration file",
-    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?(bash_|zsh_)?profile\\z",
-    "caption": "Shell profile configuration file",
-    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?(bash_|zsh_)?aliases\\z",
-    "caption": "Shell command alias configuration file",
-    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "secret_token.rb",
-    "caption": "Ruby On Rails secret token configuration file",
-    "description": "If the Rails secret token is known, it can allow for remote code execution. (http://www.exploit-db.com/exploits/27527/)"
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "omniauth.rb",
-    "caption": "OmniAuth configuration file",
-    "description": "The OmniAuth configuration file might contain client application secrets."
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "carrierwave.rb",
-    "caption": "Carrierwave configuration file",
-    "description": "Can contain credentials for online storage systems such as Amazon S3 and Google Storage."
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "schema.rb",
-    "caption": "Ruby On Rails database schema file",
-    "description": "Contains information on the database schema of a Ruby On Rails application."
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "database.yml",
-    "caption": "Potential Ruby On Rails database configuration file",
-    "description": "Might contain database credentials."
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "settings.py",
-    "caption": "Django configuration file",
-    "description": "Might contain database credentials, online storage system credentials, secret keys, etc."
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A(.*)?config(\\.inc)?\\.php\\z",
-    "caption": "PHP configuration file",
-    "description": "Might contain credentials and keys."
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "kdb",
-    "caption": "KeePass password manager database file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "agilekeychain",
-    "caption": "1Password password manager database file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "keychain",
-    "caption": "Apple Keychain database file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "regex",
-    "pattern": "\\Akey(store|ring)\\z",
-    "caption": "GNOME Keyring database file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "log",
-    "caption": "Log file",
-    "description": "Log files might contain information such as references to secret HTTP endpoints, session IDs, user information, passwords and API keys."
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "pcap",
-    "caption": "Network traffic capture file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "regex",
-    "pattern": "\\Asql(dump)?\\z",
-    "caption": "SQL dump file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "gnucash",
-    "caption": "GnuCash database file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "backup",
-    "caption": "Contains word: backup",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "dump",
-    "caption": "Contains word: dump",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "password",
-    "caption": "Contains word: password",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "credential",
-    "caption": "Contains word: credential",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "secret",
-    "caption": "Contains word: secret",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "private.*key",
-    "caption": "Contains words: private, key",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "jenkins.plugins.publish_over_ssh.BapSshPublisherPlugin.xml",
-    "caption": "Jenkins publish over SSH plugin file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "credentials.xml",
-    "caption": "Potential Jenkins credentials file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?htpasswd\\z",
-    "caption": "Apache htpasswd file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A(\\.|_)?netrc\\z",
-    "caption": "Configuration file for auto-login process",
-    "description": "Might contain username and password."
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "kwallet",
-    "caption": "KDE Wallet Manager database file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "LocalSettings.php",
-    "caption": "Potential MediaWiki configuration file",
-    "description": null
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "tblk",
-    "caption": "Tunnelblick VPN configuration file",
-    "description": null
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?gem/credentials\\z",
-    "caption": "Rubygems credentials file",
-    "description": "Might contain API key for a rubygems.org account."
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A*\\.pubxml(\\.user)?\\z",
-    "caption": "Potential MSBuild publish profile",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "Favorites.plist",
-    "caption": "Sequel Pro MySQL database manager bookmark file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "configuration.user.xpl",
-    "caption": "Little Snitch firewall configuration file",
-    "description": "Contains traffic rules for applications"
-  },
-  {
-    "part": "extension",
-    "type": "match",
-    "pattern": "dayone",
-    "caption": "Day One journal file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "journal.txt",
-    "caption": "Potential jrnl journal file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?tugboat\\z",
-    "caption": "Tugboat DigitalOcean management tool configuration",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?git-credentials\\z",
-    "caption": "git-credential-store helper credentials file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?gitconfig\\z",
-    "caption": "Git configuration file",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "knife.rb",
-    "caption": "Chef Knife configuration file",
-    "description": "Might contain references to Chef servers"
-  },
-  {
-    "part": "path",
-    "type": "regex",
-    "pattern": "\\.?chef/(.*)\\.pem\\z",
-    "caption": "Chef private key",
-    "description": "Can be used to authenticate against Chef servers"
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "proftpdpasswd",
-    "caption": "cPanel backup ProFTPd credentials file",
-    "description": "Contains usernames and password hashes for FTP accounts"
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "robomongo.json",
-    "caption": "Robomongo MongoDB manager configuration file",
-    "description": "Might contain credentials for MongoDB databases"
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "filezilla.xml",
-    "caption": "FileZilla FTP configuration file",
-    "description": "Might contain credentials for FTP servers"
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "recentservers.xml",
-    "caption": "FileZilla FTP recent servers file",
-    "description": "Might contain credentials for FTP servers"
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "ventrilo_srv.ini",
-    "caption": "Ventrilo server configuration file",
-    "description": "Might contain passwords"
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?dockercfg\\z",
-    "caption": "Docker configuration file",
-    "description": "Might contain credentials for public or private Docker registries"
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?npmrc\\z",
-    "caption": "NPM configuration file",
-    "description": "Might contain credentials for NPM registries"
-  },
-  {
-    "part": "filename",
-    "type": "match",
-    "pattern": "terraform.tfvars",
-    "caption": "Terraform variable config file",
-    "description": "Might contain credentials for terraform providers"
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "\\A\\.?env\\z",
-    "caption": "Environment configuration file",
-    "description": null
-  }
-]
diff --git a/test/fixtures/rule.json b/test/fixtures/rule.json
deleted file mode 100644
index 22b338a..0000000
--- a/test/fixtures/rule.json
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-	"part": "filename",
-	"type": "regex",
-	"pattern": "password",
-	"caption": "Contains word: password",
-	"description": null
-}
diff --git a/test/fixtures/rules.json b/test/fixtures/rules.json
deleted file mode 100644
index 8e50bce..0000000
--- a/test/fixtures/rules.json
+++ /dev/null
@@ -1,9 +0,0 @@
-[
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "password",
-    "caption": "Contains word: password",
-    "description": null
-  }
-]
diff --git a/test/fixtures/rules/gitrob.json b/test/fixtures/rules/gitrob.json
new file mode 100644
index 0000000..a64f2bd
--- /dev/null
+++ b/test/fixtures/rules/gitrob.json
@@ -0,0 +1,555 @@
+[
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_rsa\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_dsa\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_ed25519\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_ecdsa\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?ssh/config\\z",
+    "caption": "SSH configuration file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pem",
+    "caption": "Potential cryptographic private key",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "regex",
+    "pattern": "\\Akey(pair)?\\z",
+    "caption": "Potential cryptographic private key",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pkcs12",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pfx",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "p12",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "asc",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "otr.private_key",
+    "caption": "Pidgin OTR private key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash_|zsh_|z)?history\\z",
+    "caption": "Shell command history file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?mysql_history\\z",
+    "caption": "MySQL client command history file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?psql_history\\z",
+    "caption": "PostgreSQL client command history file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?pgpass\\z",
+    "caption": "PostgreSQL password file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?irb_history\\z",
+    "caption": "Ruby IRB console history file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?purple\\/accounts\\.xml\\z",
+    "caption": "Pidgin chat client account configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?xchat2?\\/servlist_?\\.conf\\z",
+    "caption": "Hexchat/XChat IRC client server list configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?irssi\\/config\\z",
+    "caption": "Irssi IRC client configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?recon-ng\\/keys\\.db\\z",
+    "caption": "Recon-ng web reconnaissance framework API key database",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?dbeaver-data-sources.xml\\z",
+    "caption": "DBeaver SQL database manager configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?muttrc\\z",
+    "caption": "Mutt e-mail client configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?s3cfg\\z",
+    "caption": "S3cmd configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?aws/credentials\\z",
+    "caption": "AWS CLI credentials file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?trc\\z",
+    "caption": "T command-line Twitter client configuration file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "ovpn",
+    "caption": "OpenVPN client configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?gitrobrc\\z",
+    "caption": "Well, this is awkward... Gitrob configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash|zsh)rc\\z",
+    "caption": "Shell configuration file",
+    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash_|zsh_)?profile\\z",
+    "caption": "Shell profile configuration file",
+    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash_|zsh_)?aliases\\z",
+    "caption": "Shell command alias configuration file",
+    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "secret_token.rb",
+    "caption": "Ruby On Rails secret token configuration file",
+    "description": "If the Rails secret token is known, it can allow for remote code execution. (http://www.exploit-db.com/exploits/27527/)"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "omniauth.rb",
+    "caption": "OmniAuth configuration file",
+    "description": "The OmniAuth configuration file might contain client application secrets."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "carrierwave.rb",
+    "caption": "Carrierwave configuration file",
+    "description": "Can contain credentials for online storage systems such as Amazon S3 and Google Storage."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "schema.rb",
+    "caption": "Ruby On Rails database schema file",
+    "description": "Contains information on the database schema of a Ruby On Rails application."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "database.yml",
+    "caption": "Potential Ruby On Rails database configuration file",
+    "description": "Might contain database credentials."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "settings.py",
+    "caption": "Django configuration file",
+    "description": "Might contain database credentials, online storage system credentials, secret keys, etc."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A(.*)?config(\\.inc)?\\.php\\z",
+    "caption": "PHP configuration file",
+    "description": "Might contain credentials and keys."
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "kdb",
+    "caption": "KeePass password manager database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "agilekeychain",
+    "caption": "1Password password manager database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "keychain",
+    "caption": "Apple Keychain database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "regex",
+    "pattern": "\\Akey(store|ring)\\z",
+    "caption": "GNOME Keyring database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "log",
+    "caption": "Log file",
+    "description": "Log files might contain information such as references to secret HTTP endpoints, session IDs, user information, passwords and API keys."
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pcap",
+    "caption": "Network traffic capture file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "regex",
+    "pattern": "\\Asql(dump)?\\z",
+    "caption": "SQL dump file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "gnucash",
+    "caption": "GnuCash database file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "backup",
+    "caption": "Contains word: backup",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "dump",
+    "caption": "Contains word: dump",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "password",
+    "caption": "Contains word: password",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "credential",
+    "caption": "Contains word: credential",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "secret",
+    "caption": "Contains word: secret",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "private.*key",
+    "caption": "Contains words: private, key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "jenkins.plugins.publish_over_ssh.BapSshPublisherPlugin.xml",
+    "caption": "Jenkins publish over SSH plugin file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "credentials.xml",
+    "caption": "Potential Jenkins credentials file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?htpasswd\\z",
+    "caption": "Apache htpasswd file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A(\\.|_)?netrc\\z",
+    "caption": "Configuration file for auto-login process",
+    "description": "Might contain username and password."
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "kwallet",
+    "caption": "KDE Wallet Manager database file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "LocalSettings.php",
+    "caption": "Potential MediaWiki configuration file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "tblk",
+    "caption": "Tunnelblick VPN configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?gem/credentials\\z",
+    "caption": "Rubygems credentials file",
+    "description": "Might contain API key for a rubygems.org account."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A*\\.pubxml(\\.user)?\\z",
+    "caption": "Potential MSBuild publish profile",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "Favorites.plist",
+    "caption": "Sequel Pro MySQL database manager bookmark file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "configuration.user.xpl",
+    "caption": "Little Snitch firewall configuration file",
+    "description": "Contains traffic rules for applications"
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "dayone",
+    "caption": "Day One journal file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "journal.txt",
+    "caption": "Potential jrnl journal file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?tugboat\\z",
+    "caption": "Tugboat DigitalOcean management tool configuration",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?git-credentials\\z",
+    "caption": "git-credential-store helper credentials file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?gitconfig\\z",
+    "caption": "Git configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "knife.rb",
+    "caption": "Chef Knife configuration file",
+    "description": "Might contain references to Chef servers"
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?chef/(.*)\\.pem\\z",
+    "caption": "Chef private key",
+    "description": "Can be used to authenticate against Chef servers"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "proftpdpasswd",
+    "caption": "cPanel backup ProFTPd credentials file",
+    "description": "Contains usernames and password hashes for FTP accounts"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "robomongo.json",
+    "caption": "Robomongo MongoDB manager configuration file",
+    "description": "Might contain credentials for MongoDB databases"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "filezilla.xml",
+    "caption": "FileZilla FTP configuration file",
+    "description": "Might contain credentials for FTP servers"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "recentservers.xml",
+    "caption": "FileZilla FTP recent servers file",
+    "description": "Might contain credentials for FTP servers"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "ventrilo_srv.ini",
+    "caption": "Ventrilo server configuration file",
+    "description": "Might contain passwords"
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?dockercfg\\z",
+    "caption": "Docker configuration file",
+    "description": "Might contain credentials for public or private Docker registries"
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?npmrc\\z",
+    "caption": "NPM configuration file",
+    "description": "Might contain credentials for NPM registries"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "terraform.tfvars",
+    "caption": "Terraform variable config file",
+    "description": "Might contain credentials for terraform providers"
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?env\\z",
+    "caption": "Environment configuration file",
+    "description": null
+  }
+]
diff --git a/test/fixtures/rules/rule.json b/test/fixtures/rules/rule.json
new file mode 100644
index 0000000..22b338a
--- /dev/null
+++ b/test/fixtures/rules/rule.json
@@ -0,0 +1,7 @@
+{
+	"part": "filename",
+	"type": "regex",
+	"pattern": "password",
+	"caption": "Contains word: password",
+	"description": null
+}
diff --git a/test/fixtures/rules/rules.json b/test/fixtures/rules/rules.json
new file mode 100644
index 0000000..8e50bce
--- /dev/null
+++ b/test/fixtures/rules/rules.json
@@ -0,0 +1,9 @@
+[
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "password",
+    "caption": "Contains word: password",
+    "description": null
+  }
+]
ed5663af172d73c0c90829df0375e8bf2eb71bdc Reads rules from file
diff --git a/lib/rules.go b/lib/rules.go
new file mode 100644
index 0000000..9aadb93
--- /dev/null
+++ b/lib/rules.go
@@ -0,0 +1,19 @@
+package diffence
+
+import (
+	"encoding/json"
+	"os"
+)
+
+func readRulesFromFile(filePath string) (*[]rule, error) {
+	rules := &[]rule{}
+
+	f, err := os.Open(filePath)
+	if err != nil {
+		return rules, err
+	}
+
+	jsonParser := json.NewDecoder(f)
+	err = jsonParser.Decode(rules)
+	return rules, err
+}
diff --git a/lib/rules_test.go b/lib/rules_test.go
new file mode 100644
index 0000000..5d3d5f6
--- /dev/null
+++ b/lib/rules_test.go
@@ -0,0 +1,51 @@
+package diffence
+
+import (
+	"reflect"
+	"testing"
+)
+
+func Test_readRules(t *testing.T) {
+	type args struct {
+		filePath string
+	}
+	tests := []struct {
+		name    string
+		args    args
+		want    *[]rule
+		wantErr bool
+	}{
+		{
+			name: "Read rules from file",
+			args: args{filePath: "./../test/fixtures/rules.json"},
+			want: &[]rule{
+				{
+					Part:        "filename",
+					Type:        "regex",
+					Pattern:     "password",
+					Caption:     "Contains word: password",
+					Description: nil,
+				},
+			},
+			wantErr: false,
+		},
+		{
+			name:    "Read rules from file",
+			args:    args{filePath: "./../test/fixtures/does_not_exist.json"},
+			want:    &[]rule{},
+			wantErr: true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := readRulesFromFile(tt.args.filePath)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("readRulesFromFile() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("readRulesFromFile() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/test/fixtures/rules.json b/test/fixtures/rules.json
index c16bc31..8e50bce 100644
--- a/test/fixtures/rules.json
+++ b/test/fixtures/rules.json
@@ -5,26 +5,5 @@
     "pattern": "password",
     "caption": "Contains word: password",
     "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "credential",
-    "caption": "Contains word: credential",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "secret",
-    "caption": "Contains word: secret",
-    "description": null
-  },
-  {
-    "part": "filename",
-    "type": "regex",
-    "pattern": "private.*key",
-    "caption": "Contains words: private, key",
-    "description": null
   }
 ]
b05ebbb92f3e4cec369e0ba95f6b66c6a5281a58 Adds go generated rules struct
diff --git a/-H b/-H
deleted file mode 100644
index 1ec8d7f..0000000
--- a/-H
+++ /dev/null
@@ -1,15 +0,0 @@
-diff --git a/README.md b/README.md
-index 82366e3..5fc99b9 100644
---- a/README.md
-+++ b/README.md
-@@ -1,7 +1,8 @@
- # systemdlogger
- 
--- Exports systemd logs to an external service, eg cloudwatch, elasticsearch.
--- Use with a cron job.
-+- Lightweight, python only, logstash alternative
-+- Exports systemd journald logs to an external service, eg cloudwatch, elasticsearch
-+- Use with a cron job
- - Python 3+
- 
- 
diff --git a/.overcommit.yml b/.overcommit.yml
index 2fe3bdd..1b01598 100644
--- a/.overcommit.yml
+++ b/.overcommit.yml
@@ -20,6 +20,9 @@ PreCommit:
     enabled: true
   GoLint:
     enabled: true
+  Generate:
+    enabled: true
+    required_executable: './bin/githooks/generate.sh'
   Interfacer:
     enabled: true
     required_executable: './bin/githooks/interfacer.sh'
diff --git a/Makefile b/Makefile
index 9cfeac1..0f426e8 100644
--- a/Makefile
+++ b/Makefile
@@ -2,9 +2,11 @@ USER = techjacker
 REPO = systemdlogger
 COMMIT_ID = a4e1c01c137c2218684fd59da54d769623ac567f
 
+GITROB_RULES = https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json
+
+# https://github.com/michenriksen/gitrob/blob/master/signatures.json
 rules:
-	@curl -sL https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json \
-		> ./test/fixtures/gitrob.json
+	@curl -s $(GITROB_RULES) > ./test/fixtures/gitrob.json
 
 diff:
 	@curl -L https://api.github.com/repos/$(USER)/$(REPO)/commits/$(COMMIT_ID) \
diff --git a/bin/githooks/generate.sh b/bin/githooks/generate.sh
new file mode 100755
index 0000000..5119e58
--- /dev/null
+++ b/bin/githooks/generate.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+####################
+# go get github.com/ChimeraCoder/gojson/gojson
+####################
+go generate ./...
diff --git a/lib/rule.go b/lib/rule.go
new file mode 100644
index 0000000..ee60223
--- /dev/null
+++ b/lib/rule.go
@@ -0,0 +1,9 @@
+package diffence
+
+type rule struct {
+	Caption     string      `'rule':"caption"`
+	Description interface{} `'rule':"description"`
+	Part        string      `'rule':"part"`
+	Pattern     string      `'rule':"pattern"`
+	Type        string      `'rule':"type"`
+}
diff --git a/lib/rule_tmpl.go b/lib/rule_tmpl.go
new file mode 100644
index 0000000..59ff8c4
--- /dev/null
+++ b/lib/rule_tmpl.go
@@ -0,0 +1,3 @@
+package diffence
+
+//go:generate gojson -name rule -input ./../test/fixtures/rule.json -o rule.go -pkg diffence -subStruct -tags 'rule'
diff --git a/test/fixtures/rule.json b/test/fixtures/rule.json
new file mode 100644
index 0000000..22b338a
--- /dev/null
+++ b/test/fixtures/rule.json
@@ -0,0 +1,7 @@
+{
+	"part": "filename",
+	"type": "regex",
+	"pattern": "password",
+	"caption": "Contains word: password",
+	"description": null
+}
4c56fc2d21a001e1090d8d46f7458b669a0b5698 Adds gitrob rules test fixtures
diff --git a/Makefile b/Makefile
index e322c8f..9cfeac1 100644
--- a/Makefile
+++ b/Makefile
@@ -2,6 +2,10 @@ USER = techjacker
 REPO = systemdlogger
 COMMIT_ID = a4e1c01c137c2218684fd59da54d769623ac567f
 
+rules:
+	@curl -sL https://raw.githubusercontent.com/michenriksen/gitrob/master/signatures.json \
+		> ./test/fixtures/gitrob.json
+
 diff:
 	@curl -L https://api.github.com/repos/$(USER)/$(REPO)/commits/$(COMMIT_ID) \
 		-H "Accept: application/vnd.github.VERSION.diff"
diff --git a/test/fixtures/gitrob.json b/test/fixtures/gitrob.json
new file mode 100644
index 0000000..a64f2bd
--- /dev/null
+++ b/test/fixtures/gitrob.json
@@ -0,0 +1,555 @@
+[
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_rsa\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_dsa\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_ed25519\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A.*_ecdsa\\z",
+    "caption": "Private SSH key",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?ssh/config\\z",
+    "caption": "SSH configuration file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pem",
+    "caption": "Potential cryptographic private key",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "regex",
+    "pattern": "\\Akey(pair)?\\z",
+    "caption": "Potential cryptographic private key",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pkcs12",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pfx",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "p12",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "asc",
+    "caption": "Potential cryptographic key bundle",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "otr.private_key",
+    "caption": "Pidgin OTR private key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash_|zsh_|z)?history\\z",
+    "caption": "Shell command history file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?mysql_history\\z",
+    "caption": "MySQL client command history file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?psql_history\\z",
+    "caption": "PostgreSQL client command history file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?pgpass\\z",
+    "caption": "PostgreSQL password file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?irb_history\\z",
+    "caption": "Ruby IRB console history file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?purple\\/accounts\\.xml\\z",
+    "caption": "Pidgin chat client account configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?xchat2?\\/servlist_?\\.conf\\z",
+    "caption": "Hexchat/XChat IRC client server list configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?irssi\\/config\\z",
+    "caption": "Irssi IRC client configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?recon-ng\\/keys\\.db\\z",
+    "caption": "Recon-ng web reconnaissance framework API key database",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?dbeaver-data-sources.xml\\z",
+    "caption": "DBeaver SQL database manager configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?muttrc\\z",
+    "caption": "Mutt e-mail client configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?s3cfg\\z",
+    "caption": "S3cmd configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?aws/credentials\\z",
+    "caption": "AWS CLI credentials file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?trc\\z",
+    "caption": "T command-line Twitter client configuration file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "ovpn",
+    "caption": "OpenVPN client configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?gitrobrc\\z",
+    "caption": "Well, this is awkward... Gitrob configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash|zsh)rc\\z",
+    "caption": "Shell configuration file",
+    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash_|zsh_)?profile\\z",
+    "caption": "Shell profile configuration file",
+    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?(bash_|zsh_)?aliases\\z",
+    "caption": "Shell command alias configuration file",
+    "description": "Shell configuration files might contain information such as server hostnames, passwords and API keys."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "secret_token.rb",
+    "caption": "Ruby On Rails secret token configuration file",
+    "description": "If the Rails secret token is known, it can allow for remote code execution. (http://www.exploit-db.com/exploits/27527/)"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "omniauth.rb",
+    "caption": "OmniAuth configuration file",
+    "description": "The OmniAuth configuration file might contain client application secrets."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "carrierwave.rb",
+    "caption": "Carrierwave configuration file",
+    "description": "Can contain credentials for online storage systems such as Amazon S3 and Google Storage."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "schema.rb",
+    "caption": "Ruby On Rails database schema file",
+    "description": "Contains information on the database schema of a Ruby On Rails application."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "database.yml",
+    "caption": "Potential Ruby On Rails database configuration file",
+    "description": "Might contain database credentials."
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "settings.py",
+    "caption": "Django configuration file",
+    "description": "Might contain database credentials, online storage system credentials, secret keys, etc."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A(.*)?config(\\.inc)?\\.php\\z",
+    "caption": "PHP configuration file",
+    "description": "Might contain credentials and keys."
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "kdb",
+    "caption": "KeePass password manager database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "agilekeychain",
+    "caption": "1Password password manager database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "keychain",
+    "caption": "Apple Keychain database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "regex",
+    "pattern": "\\Akey(store|ring)\\z",
+    "caption": "GNOME Keyring database file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "log",
+    "caption": "Log file",
+    "description": "Log files might contain information such as references to secret HTTP endpoints, session IDs, user information, passwords and API keys."
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "pcap",
+    "caption": "Network traffic capture file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "regex",
+    "pattern": "\\Asql(dump)?\\z",
+    "caption": "SQL dump file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "gnucash",
+    "caption": "GnuCash database file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "backup",
+    "caption": "Contains word: backup",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "dump",
+    "caption": "Contains word: dump",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "password",
+    "caption": "Contains word: password",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "credential",
+    "caption": "Contains word: credential",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "secret",
+    "caption": "Contains word: secret",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "private.*key",
+    "caption": "Contains words: private, key",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "jenkins.plugins.publish_over_ssh.BapSshPublisherPlugin.xml",
+    "caption": "Jenkins publish over SSH plugin file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "credentials.xml",
+    "caption": "Potential Jenkins credentials file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?htpasswd\\z",
+    "caption": "Apache htpasswd file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A(\\.|_)?netrc\\z",
+    "caption": "Configuration file for auto-login process",
+    "description": "Might contain username and password."
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "kwallet",
+    "caption": "KDE Wallet Manager database file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "LocalSettings.php",
+    "caption": "Potential MediaWiki configuration file",
+    "description": null
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "tblk",
+    "caption": "Tunnelblick VPN configuration file",
+    "description": null
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?gem/credentials\\z",
+    "caption": "Rubygems credentials file",
+    "description": "Might contain API key for a rubygems.org account."
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A*\\.pubxml(\\.user)?\\z",
+    "caption": "Potential MSBuild publish profile",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "Favorites.plist",
+    "caption": "Sequel Pro MySQL database manager bookmark file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "configuration.user.xpl",
+    "caption": "Little Snitch firewall configuration file",
+    "description": "Contains traffic rules for applications"
+  },
+  {
+    "part": "extension",
+    "type": "match",
+    "pattern": "dayone",
+    "caption": "Day One journal file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "journal.txt",
+    "caption": "Potential jrnl journal file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?tugboat\\z",
+    "caption": "Tugboat DigitalOcean management tool configuration",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?git-credentials\\z",
+    "caption": "git-credential-store helper credentials file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?gitconfig\\z",
+    "caption": "Git configuration file",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "knife.rb",
+    "caption": "Chef Knife configuration file",
+    "description": "Might contain references to Chef servers"
+  },
+  {
+    "part": "path",
+    "type": "regex",
+    "pattern": "\\.?chef/(.*)\\.pem\\z",
+    "caption": "Chef private key",
+    "description": "Can be used to authenticate against Chef servers"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "proftpdpasswd",
+    "caption": "cPanel backup ProFTPd credentials file",
+    "description": "Contains usernames and password hashes for FTP accounts"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "robomongo.json",
+    "caption": "Robomongo MongoDB manager configuration file",
+    "description": "Might contain credentials for MongoDB databases"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "filezilla.xml",
+    "caption": "FileZilla FTP configuration file",
+    "description": "Might contain credentials for FTP servers"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "recentservers.xml",
+    "caption": "FileZilla FTP recent servers file",
+    "description": "Might contain credentials for FTP servers"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "ventrilo_srv.ini",
+    "caption": "Ventrilo server configuration file",
+    "description": "Might contain passwords"
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?dockercfg\\z",
+    "caption": "Docker configuration file",
+    "description": "Might contain credentials for public or private Docker registries"
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?npmrc\\z",
+    "caption": "NPM configuration file",
+    "description": "Might contain credentials for NPM registries"
+  },
+  {
+    "part": "filename",
+    "type": "match",
+    "pattern": "terraform.tfvars",
+    "caption": "Terraform variable config file",
+    "description": "Might contain credentials for terraform providers"
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "\\A\\.?env\\z",
+    "caption": "Environment configuration file",
+    "description": null
+  }
+]
diff --git a/test/fixtures/rules.json b/test/fixtures/rules.json
index e69de29..c16bc31 100644
--- a/test/fixtures/rules.json
+++ b/test/fixtures/rules.json
@@ -0,0 +1,30 @@
+[
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "password",
+    "caption": "Contains word: password",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "credential",
+    "caption": "Contains word: credential",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "secret",
+    "caption": "Contains word: secret",
+    "description": null
+  },
+  {
+    "part": "filename",
+    "type": "regex",
+    "pattern": "private.*key",
+    "caption": "Contains words: private, key",
+    "description": null
+  }
+]
840bb719329dc883143924d3be05e6e378c214d6 Adds github diff fixture
diff --git a/-H b/-H
new file mode 100644
index 0000000..1ec8d7f
--- /dev/null
+++ b/-H
@@ -0,0 +1,15 @@
+diff --git a/README.md b/README.md
+index 82366e3..5fc99b9 100644
+--- a/README.md
++++ b/README.md
+@@ -1,7 +1,8 @@
+ # systemdlogger
+ 
+-- Exports systemd logs to an external service, eg cloudwatch, elasticsearch.
+-- Use with a cron job.
++- Lightweight, python only, logstash alternative
++- Exports systemd journald logs to an external service, eg cloudwatch, elasticsearch
++- Use with a cron job
+ - Python 3+
+ 
+ 
diff --git a/Makefile b/Makefile
index 8a71e9a..e322c8f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,11 @@
+USER = techjacker
+REPO = systemdlogger
+COMMIT_ID = a4e1c01c137c2218684fd59da54d769623ac567f
+
+diff:
+	@curl -L https://api.github.com/repos/$(USER)/$(REPO)/commits/$(COMMIT_ID) \
+		-H "Accept: application/vnd.github.VERSION.diff"
+
 run:
 	@go build ./cmd/diffence && ./diffence
 
diff --git a/test/fixtures/diff.txt b/test/fixtures/diff.txt
new file mode 100644
index 0000000..07f8683
--- /dev/null
+++ b/test/fixtures/diff.txt
@@ -0,0 +1,13 @@
+diff --git a/README.md b/README.md
+index 82366e3..5fc99b9 100644
+--- a/README.md
++++ b/README.md
+@@ -1,7 +1,8 @@
+ # systemdlogger
+
+-- Exports systemd logs to an external service, eg cloudwatch, elasticsearch.
+-- Use with a cron job.
++- Lightweight, python only, logstash alternative
++- Exports systemd journald logs to an external service, eg cloudwatch, elasticsearch
++- Use with a cron job
+ - Python 3+
1209dc458df1fd7441cd6921441ff0c7f7c17856 Stubs new project layout for CLI tool and lib
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..eb23833
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,27 @@
+diffence
+releases
+
+# Compiled Object files, Static and Dynamic libs (Shared Objects)
+*.o
+*.a
+*.so
+
+# Folders
+_obj
+_test
+
+# Architecture specific extensions/prefixes
+*.[568vq]
+[568vq].out
+
+*.cgo1.go
+*.cgo2.c
+_cgo_defun.c
+_cgo_gotypes.go
+_cgo_export.*
+
+_testmain.go
+
+*.exe
+*.test
+*.prof
diff --git a/.overcommit.yml b/.overcommit.yml
new file mode 100644
index 0000000..2fe3bdd
--- /dev/null
+++ b/.overcommit.yml
@@ -0,0 +1,29 @@
+# Use this file to configure the Overcommit hooks you wish to use. This will
+# extend the default configuration defined in:
+# https://github.com/brigade/overcommit/blob/master/config/default.yml
+#
+# At the topmost level of this YAML file is a key representing type of hook
+# being run (e.g. pre-commit, commit-msg, etc.). Within each type you can
+# customize each hook, such as whether to only run it on certain files (via
+# `include`), whether to only display output if it fails (via `quiet`), etc.
+#
+# For a complete list of hooks, see:
+# https://github.com/brigade/overcommit/tree/master/lib/overcommit/hook
+#
+# For a complete list of options that you can use to customize hooks, see:
+# https://github.com/brigade/overcommit#configuration
+#
+# Uncomment the following lines to make the configuration take effect.
+
+PreCommit:
+  GoVet:
+    enabled: true
+  GoLint:
+    enabled: true
+  Interfacer:
+    enabled: true
+    required_executable: './bin/githooks/interfacer.sh'
+
+CommitMsg:
+  CapitalizedSubject:
+    enabled: false
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..8a71e9a
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,7 @@
+run:
+	@go build ./cmd/diffence && ./diffence
+
+test:
+	@go test -v ./...
+
+.PHONY: test run
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..cfdefa5
--- /dev/null
+++ b/README.md
@@ -0,0 +1,84 @@
+# diffence
+
+Checks a diff for offensive content.
+
+-----------------------------------------------------------
+
+## Install CLI tool
+
+### Binary
+[Download](../../releases) the latest stable release.
+
+### Source
+```
+go get -u github.com/techjacker/diffence/cmd/diffence
+```
+
+
+-----------------------------------------------------------
+
+## Usage
+```
+```
+
+
+-----------------------------------------------------------
+## JSON Configuration
+
+By default the CLI tool looks for config.json in $PWD. You can specify a custom location with the `config` flag, eg:
+
+```Shell
+diffence -config ./test/fixtures/config.json
+```
+
+
+#### Example JSON Config
+```json
+{
+	"rules": {
+		"jsonPath": "./test/fixtures/rules.json"
+	}
+}
+```
+
+-----------------------------------------------------------
+
+## Tests
+
+```
+go test ./...
+```
+
+-----------------------------------------------------------
+
+## Release
+
+Update the vars in ```env.sh```.
+
+```shell
+$ release
+```
+
+-----------------------------------------------------------
+
+## Local Development
+
+
+#### Build & Run Locally
+```shell
+go install ./cmd/diffence && diffence -config ./test/fixtures/config.json
+```
+
+OR
+
+```shell
+go build ./cmd/diffence && ./diffence -config ./test/fixtures/config.json
+```
+
+
+#### Check for race conditions
+
+```shell
+go run -race ./cmd/diffence/main.go -config ./test/fixtures/config.json
+```
+
diff --git a/bin/githooks/interfacer.sh b/bin/githooks/interfacer.sh
new file mode 100755
index 0000000..f59cf0a
--- /dev/null
+++ b/bin/githooks/interfacer.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+####################
+# https://github.com/mvdan/interfacer/
+# go get -u github.com/mvdan/interfacer/cmd/interfacer
+####################
+
+OUT=$(interfacer $(go list ./... | grep -v /vendor/))
+
+if [[ ! -z $OUT ]]; then
+	echo "$OUT"
+	exit 1
+fi
diff --git a/env.sh b/env.sh
new file mode 100644
index 0000000..de43e7c
--- /dev/null
+++ b/env.sh
@@ -0,0 +1,2 @@
+RELEASE_VERSION="0.1.0"
+RELEASE_BUILD_PATH="./cmd/diffence"
diff --git a/lib/hello.go b/lib/hello.go
new file mode 100644
index 0000000..c24409b
--- /dev/null
+++ b/lib/hello.go
@@ -0,0 +1,12 @@
+package diffence
+
+import "fmt"
+
+// Hello says whatever you asks it to say
+func Hello(msg string) {
+	fmt.Println(noop(msg))
+}
+
+func noop(msg string) string {
+	return msg
+}
diff --git a/lib/hello_test.go b/lib/hello_test.go
new file mode 100644
index 0000000..4a1a52d
--- /dev/null
+++ b/lib/hello_test.go
@@ -0,0 +1,27 @@
+package diffence
+
+import "testing"
+
+func Test_noop(t *testing.T) {
+	type args struct {
+		msg string
+	}
+	tests := []struct {
+		name string
+		args args
+		want string
+	}{
+		{
+			name: "no op test",
+			args: args{msg: "test message"},
+			want: "test message",
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := noop(tt.args.msg); got != tt.want {
+				t.Errorf("noop() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/test/fixtures/config.json b/test/fixtures/config.json
new file mode 100644
index 0000000..1d1814e
--- /dev/null
+++ b/test/fixtures/config.json
@@ -0,0 +1,5 @@
+{
+	"rules": {
+		"jsonPath": "./test/fixtures/rules.json"
+	}
+}
diff --git a/test/fixtures/rules.json b/test/fixtures/rules.json
new file mode 100644
index 0000000..e69de29
